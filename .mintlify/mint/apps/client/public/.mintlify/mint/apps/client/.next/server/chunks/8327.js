"use strict";exports.id=8327,exports.ids=[8327],exports.modules={828327:(a,b,c)=>{c.d(b,{importSPKI:()=>z,jwtVerify:()=>U});var d=c(504573),e=c(977598);let f=new TextEncoder,g=new TextDecoder,h=a=>new Uint8Array(d.Buffer.from(function(a){let b=a;return b instanceof Uint8Array&&(b=g.decode(b)),b}(a),"base64"));class i extends Error{static get code(){return"ERR_JOSE_GENERIC"}code="ERR_JOSE_GENERIC";constructor(a){super(a),this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}class j extends i{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}code="ERR_JWT_CLAIM_VALIDATION_FAILED";claim;reason;payload;constructor(a,b,c="unspecified",d="unspecified"){super(a),this.claim=c,this.reason=d,this.payload=b}}class k extends i{static get code(){return"ERR_JWT_EXPIRED"}code="ERR_JWT_EXPIRED";claim;reason;payload;constructor(a,b,c="unspecified",d="unspecified"){super(a),this.claim=c,this.reason=d,this.payload=b}}class l extends i{static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}code="ERR_JOSE_ALG_NOT_ALLOWED"}class m extends i{static get code(){return"ERR_JOSE_NOT_SUPPORTED"}code="ERR_JOSE_NOT_SUPPORTED"}class n extends i{static get code(){return"ERR_JWS_INVALID"}code="ERR_JWS_INVALID"}class o extends i{static get code(){return"ERR_JWT_INVALID"}code="ERR_JWT_INVALID"}Symbol.asyncIterator;class p extends i{static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";message="signature verification failed"}var q=c(257975);let r=a=>q.types.isKeyObject(a),s=e.webcrypto,t=a=>q.types.isCryptoKey(a),u=a=>r(a)||t(a),v=["KeyObject"];function w(a,b,...c){if(c.length>2){let b=c.pop();a+=`one of type ${c.join(", ")}, or ${b}.`}else 2===c.length?a+=`one of type ${c[0]} or ${c[1]}.`:a+=`of type ${c[0]}.`;return null==b?a+=` Received ${b}`:"function"==typeof b&&b.name?a+=` Received function ${b.name}`:"object"==typeof b&&null!=b&&b.constructor?.name&&(a+=` Received an instance of ${b.constructor.name}`),a}(globalThis.CryptoKey||s?.CryptoKey)&&v.push("CryptoKey");let x=(a,...b)=>w("Key must be ",a,...b);function y(a,b,...c){return w(`Key for the ${a} algorithm must be `,b,...c)}async function z(a,b,c){if("string"!=typeof a||0!==a.indexOf("-----BEGIN PUBLIC KEY-----"))throw TypeError('"spki" must be SPKI formatted string');return(0,e.createPublicKey)({key:d.Buffer.from(a.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,""),"base64"),type:"spki",format:"der"})}new WeakMap,(0,q.promisify)(e.generateKeyPair),(0,q.promisify)(e.pbkdf2),(0,q.deprecate)(()=>e.constants.RSA_PKCS1_PADDING,'The RSA1_5 "alg" (JWE Algorithm) is deprecated and will be removed in the next major revision.');let A=function(a,b,c,d,e){let f;if(void 0!==e.crit&&d?.crit===void 0)throw new a('"crit" (Critical) Header Parameter MUST be integrity protected');if(!d||void 0===d.crit)return new Set;if(!Array.isArray(d.crit)||0===d.crit.length||d.crit.some(a=>"string"!=typeof a||0===a.length))throw new a('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');for(let g of(f=void 0!==c?new Map([...Object.entries(c),...b.entries()]):b,d.crit)){if(!f.has(g))throw new m(`Extension Header Parameter "${g}" is not recognized`);if(void 0===e[g])throw new a(`Extension Header Parameter "${g}" is missing`);if(f.get(g)&&void 0===d[g])throw new a(`Extension Header Parameter "${g}" MUST be integrity protected`)}return new Set(d.crit)};function B(a){switch(a){case"PS256":case"RS256":case"ES256":case"ES256K":return"sha256";case"PS384":case"RS384":case"ES384":return"sha384";case"PS512":case"RS512":case"ES512":return"sha512";case"EdDSA":return;default:throw new m(`alg ${a} is not supported either by JOSE or your javascript runtime`)}}Symbol();let C=(a,b)=>{let{modulusLength:c}=a.asymmetricKeyDetails;if("number"!=typeof c||c<2048)throw TypeError(`${b} requires key modulusLength to be 2048 bits or larger`)},D={padding:e.constants.RSA_PKCS1_PSS_PADDING,saltLength:e.constants.RSA_PSS_SALTLEN_DIGEST},E=new Map([["ES256","P-256"],["ES256K","secp256k1"],["ES384","P-384"],["ES512","P-521"]]);function F(a,b){switch(a){case"EdDSA":if(!["ed25519","ed448"].includes(b.asymmetricKeyType))throw TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");return b;case"RS256":case"RS384":case"RS512":if("rsa"!==b.asymmetricKeyType)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");return C(b,a),b;case"PS256":case"PS384":case"PS512":if("rsa-pss"===b.asymmetricKeyType){let{hashAlgorithm:c,mgf1HashAlgorithm:d,saltLength:e}=b.asymmetricKeyDetails,f=parseInt(a.slice(-3),10);if(void 0!==c&&(c!==`sha${f}`||d!==c))throw TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${a}`);if(void 0!==e&&e>f>>3)throw TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${a}`)}else if("rsa"!==b.asymmetricKeyType)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");return C(b,a),{key:b,...D};case"ES256":case"ES256K":case"ES384":case"ES512":{if("ec"!==b.asymmetricKeyType)throw TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");let c=((a,b)=>{let c;if(t(a))c=e.KeyObject.from(a);else if(r(a))c=a;else throw TypeError(x(a,...v));if("secret"===c.type)throw TypeError('only "private" or "public" type keys can be used for this operation');switch(c.asymmetricKeyType){case"ed25519":case"ed448":return`Ed${c.asymmetricKeyType.slice(2)}`;case"x25519":case"x448":return`X${c.asymmetricKeyType.slice(1)}`;case"ec":{let a=c.asymmetricKeyDetails.namedCurve;switch(a){case"prime256v1":return"P-256";case"secp384r1":return"P-384";case"secp521r1":return"P-521";case"secp256k1":return"secp256k1";default:throw new m("Unsupported key curve for this operation")}}default:throw TypeError("Invalid asymmetric key type for this operation")}})(b),d=E.get(a);if(c!==d)throw TypeError(`Invalid key curve for the algorithm, its curve must be ${d}, got ${c}`);return{dsaEncoding:"ieee-p1363",key:b}}default:throw new m(`alg ${a} is not supported either by JOSE or your javascript runtime`)}}function G(a,b="algorithm.name"){return TypeError(`CryptoKey does not support this operation, its ${b} must be ${a}`)}function H(a,b){return a.name===b}function I(a){return parseInt(a.name.slice(4),10)}function J(a,b,c){if(b instanceof Uint8Array){if(!a.startsWith("HS"))throw TypeError(x(b,...v));return(0,e.createSecretKey)(b)}if(b instanceof e.KeyObject)return b;if(t(b))return!function(a,b,...c){switch(b){case"HS256":case"HS384":case"HS512":{if(!H(a.algorithm,"HMAC"))throw G("HMAC");let c=parseInt(b.slice(2),10);if(I(a.algorithm.hash)!==c)throw G(`SHA-${c}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!H(a.algorithm,"RSASSA-PKCS1-v1_5"))throw G("RSASSA-PKCS1-v1_5");let c=parseInt(b.slice(2),10);if(I(a.algorithm.hash)!==c)throw G(`SHA-${c}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!H(a.algorithm,"RSA-PSS"))throw G("RSA-PSS");let c=parseInt(b.slice(2),10);if(I(a.algorithm.hash)!==c)throw G(`SHA-${c}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==a.algorithm.name&&"Ed448"!==a.algorithm.name)throw G("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!H(a.algorithm,"ECDSA"))throw G("ECDSA");let c=function(a){switch(a){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw Error("unreachable")}}(b);if(a.algorithm.namedCurve!==c)throw G(c,"algorithm.namedCurve");break}default:throw TypeError("CryptoKey does not support this operation")}if(c.length&&!c.some(b=>a.usages.includes(b))){let a="CryptoKey does not support this operation, its usages must include ";if(c.length>2){let b=c.pop();a+=`one of ${c.join(", ")}, or ${b}.`}else 2===c.length?a+=`one of ${c[0]} or ${c[1]}.`:a+=`${c[0]}.`;throw TypeError(a)}}(b,a,c),e.KeyObject.from(b);throw TypeError(x(b,...v,"Uint8Array"))}let K=(0,q.promisify)(e.sign),L=async(a,b,c)=>{let d=J(a,b,"sign");if(a.startsWith("HS")){let b=e.createHmac(function(a){switch(a){case"HS256":return"sha256";case"HS384":return"sha384";case"HS512":return"sha512";default:throw new m(`alg ${a} is not supported either by JOSE or your javascript runtime`)}}(a),d);return b.update(c),b.digest()}return K(B(a),c,F(a,d))},M=(0,q.promisify)(e.verify),N=async(a,b,c,d)=>{let f=J(a,b,"verify");if(a.startsWith("HS")){let b=await L(a,f,d);try{return e.timingSafeEqual(c,b)}catch{return!1}}let g=B(a),h=F(a,f);try{return await M(g,d,h,c)}catch{return!1}};function O(a){if("object"!=typeof a||null===a||"[object Object]"!==Object.prototype.toString.call(a))return!1;if(null===Object.getPrototypeOf(a))return!0;let b=a;for(;null!==Object.getPrototypeOf(b);)b=Object.getPrototypeOf(b);return Object.getPrototypeOf(a)===b}async function P(a,b,c){var d;let e,i;if(!O(a))throw new n("Flattened JWS must be an object");if(void 0===a.protected&&void 0===a.header)throw new n('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==a.protected&&"string"!=typeof a.protected)throw new n("JWS Protected Header incorrect type");if(void 0===a.payload)throw new n("JWS Payload missing");if("string"!=typeof a.signature)throw new n("JWS Signature missing or incorrect type");if(void 0!==a.header&&!O(a.header))throw new n("JWS Unprotected Header incorrect type");let j={};if(a.protected)try{let b=h(a.protected);j=JSON.parse(g.decode(b))}catch{throw new n("JWS Protected Header is invalid")}if(!((...a)=>{let b,c=a.filter(Boolean);if(0===c.length||1===c.length)return!0;for(let a of c){let c=Object.keys(a);if(!b||0===b.size){b=new Set(c);continue}for(let a of c){if(b.has(a))return!1;b.add(a)}}return!0})(j,a.header))throw new n("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let k={...j,...a.header},m=A(n,new Map([["b64",!0]]),c?.crit,j,k),o=!0;if(m.has("b64")&&"boolean"!=typeof(o=j.b64))throw new n('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:q}=k;if("string"!=typeof q||!q)throw new n('JWS "alg" (Algorithm) Header Parameter missing or invalid');let r=c&&((a,b)=>{if(void 0!==b&&(!Array.isArray(b)||b.some(a=>"string"!=typeof a)))throw TypeError(`"${a}" option must be an array of strings`);if(b)return new Set(b)})("algorithms",c.algorithms);if(r&&!r.has(q))throw new l('"alg" (Algorithm) Header Parameter value not allowed');if(o){if("string"!=typeof a.payload)throw new n("JWS Payload must be a string")}else if("string"!=typeof a.payload&&!(a.payload instanceof Uint8Array))throw new n("JWS Payload must be a string or an Uint8Array instance");let s=!1;"function"==typeof b&&(b=await b(j,a),s=!0),d=b,q.startsWith("HS")||"dir"===q||q.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(q)?((a,b)=>{if(!(b instanceof Uint8Array)){if(!u(b))throw TypeError(y(a,b,...v,"Uint8Array"));if("secret"!==b.type)throw TypeError(`${v.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}})(q,d):((a,b,c)=>{if(!u(b))throw TypeError(y(a,b,...v));if("secret"===b.type)throw TypeError(`${v.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===c&&"public"===b.type)throw TypeError(`${v.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===c&&"public"===b.type)throw TypeError(`${v.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(b.algorithm&&"verify"===c&&"private"===b.type)throw TypeError(`${v.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(b.algorithm&&"encrypt"===c&&"private"===b.type)throw TypeError(`${v.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)})(q,d,"verify");let t=function(...a){let b=new Uint8Array(a.reduce((a,{length:b})=>a+b,0)),c=0;for(let d of a)b.set(d,c),c+=d.length;return b}(f.encode(a.protected??""),f.encode("."),"string"==typeof a.payload?f.encode(a.payload):a.payload);try{e=h(a.signature)}catch{throw new n("Failed to base64url decode the signature")}if(!await N(q,b,e,t))throw new p;if(o)try{i=h(a.payload)}catch{throw new n("Failed to base64url decode the payload")}else i="string"==typeof a.payload?f.encode(a.payload):a.payload;let w={payload:i};return(void 0!==a.protected&&(w.protectedHeader=j),void 0!==a.header&&(w.unprotectedHeader=a.header),s)?{...w,key:b}:w}async function Q(a,b,c){if(a instanceof Uint8Array&&(a=g.decode(a)),"string"!=typeof a)throw new n("Compact JWS must be a string or Uint8Array");let{0:d,1:e,2:f,length:h}=a.split(".");if(3!==h)throw new n("Invalid Compact JWS");let i=await P({payload:e,protected:d,signature:f},b,c),j={payload:i.payload,protectedHeader:i.protectedHeader};return"function"==typeof b?{...j,key:i.key}:j}let R=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,S=a=>{let b,c=R.exec(a);if(!c||c[4]&&c[1])throw TypeError("Invalid time period format");let d=parseFloat(c[2]);switch(c[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":b=Math.round(d);break;case"minute":case"minutes":case"min":case"mins":case"m":b=Math.round(60*d);break;case"hour":case"hours":case"hr":case"hrs":case"h":b=Math.round(3600*d);break;case"day":case"days":case"d":b=Math.round(86400*d);break;case"week":case"weeks":case"w":b=Math.round(604800*d);break;default:b=Math.round(0x1e187e0*d)}return"-"===c[1]||"ago"===c[4]?-b:b},T=a=>a.toLowerCase().replace(/^application\//,"");async function U(a,b,c){let d=await Q(a,b,c);if(d.protectedHeader.crit?.includes("b64")&&!1===d.protectedHeader.b64)throw new o("JWTs MUST NOT use unencoded payload");let e={payload:((a,b,c={})=>{let d,e,f,h;try{d=JSON.parse(g.decode(b))}catch{}if(!O(d))throw new o("JWT Claims Set must be a top-level JSON object");let{typ:i}=c;if(i&&("string"!=typeof a.typ||T(a.typ)!==T(i)))throw new j('unexpected "typ" JWT header value',d,"typ","check_failed");let{requiredClaims:l=[],issuer:m,subject:n,audience:p,maxTokenAge:q}=c,r=[...l];for(let a of(void 0!==q&&r.push("iat"),void 0!==p&&r.push("aud"),void 0!==n&&r.push("sub"),void 0!==m&&r.push("iss"),new Set(r.reverse())))if(!(a in d))throw new j(`missing required "${a}" claim`,d,a,"missing");if(m&&!(Array.isArray(m)?m:[m]).includes(d.iss))throw new j('unexpected "iss" claim value',d,"iss","check_failed");if(n&&d.sub!==n)throw new j('unexpected "sub" claim value',d,"sub","check_failed");if(p&&(f=d.aud,h="string"==typeof p?[p]:p,"string"==typeof f?!h.includes(f):!(!!Array.isArray(f)&&h.some(Set.prototype.has.bind(new Set(f))))))throw new j('unexpected "aud" claim value',d,"aud","check_failed");switch(typeof c.clockTolerance){case"string":e=S(c.clockTolerance);break;case"number":e=c.clockTolerance;break;case"undefined":e=0;break;default:throw TypeError("Invalid clockTolerance option type")}let{currentDate:s}=c,t=Math.floor((s||new Date).getTime()/1e3);if((void 0!==d.iat||q)&&"number"!=typeof d.iat)throw new j('"iat" claim must be a number',d,"iat","invalid");if(void 0!==d.nbf){if("number"!=typeof d.nbf)throw new j('"nbf" claim must be a number',d,"nbf","invalid");if(d.nbf>t+e)throw new j('"nbf" claim timestamp check failed',d,"nbf","check_failed")}if(void 0!==d.exp){if("number"!=typeof d.exp)throw new j('"exp" claim must be a number',d,"exp","invalid");if(d.exp<=t-e)throw new k('"exp" claim timestamp check failed',d,"exp","check_failed")}if(q){let a=t-d.iat;if(a-e>("number"==typeof q?q:S(q)))throw new k('"iat" claim timestamp check failed (too far in the past)',d,"iat","check_failed");if(a<0-e)throw new j('"iat" claim timestamp check failed (it should be in the past)',d,"iat","check_failed")}return d})(d.protectedHeader,d.payload,c),protectedHeader:d.protectedHeader};return"function"==typeof b?{...e,key:d.key}:e}c(937067),c(344708),c(478474),"undefined"==typeof navigator||navigator.userAgent?.startsWith?.("Mozilla/5.0 "),(0,q.promisify)(e.generateKeyPair)}};