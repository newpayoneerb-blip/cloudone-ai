"use strict";exports.id=4692,exports.ids=[4692],exports.modules={894692:(a,b,c)=>{let d;c.d(b,{z8:()=>fV,NW:()=>he});let e=a=>Array.isArray(a)?a:[a],f=Array,g=(a,b)=>a.includes(b),h=(a,b=0)=>[...Array(a)].map((a,c)=>c+b),i=(a,b,c)=>void 0===a?void 0===b?[]:Array.isArray(b)?b:[b]:(c?.prepend?Array.isArray(b)?a.unshift(...b):a.unshift(b):Array.isArray(b)?a.push(...b):a.push(b),a),j=(a,b)=>null==b?a??[]:null==a?e(b):a.concat(b),k=(a,b,c)=>{if(void 0===a)return Array.isArray(b)?b:[b];let d=c?.isEqual??((a,b)=>a===b);for(let c of e(b))a.some(a=>d(a,c))||a.push(c);return a},l=(a,b,c)=>a.length===b.length&&a.every(c?.isEqual?(a,d)=>c.isEqual(a,b[d]):(a,c)=>a===b[c]),m=(a,b)=>n(a)===b,n=a=>{let b=typeof a;return"object"===b?null===a?"null":"object":"function"===b?"object":b},o={boolean:"boolean",null:"null",undefined:"undefined",bigint:"a bigint",number:"a number",object:"an object",string:"a string",symbol:"a symbol"},p={...o,function:"a function"};class q extends Error{}let r=a=>s(a,q),s=(a,b=Error)=>{throw new b(a)};class t extends Error{name="ParseError"}let u=a=>s(a,t),v=a=>` ${a}`,w=Object.entries,x=(a,b)=>a in b;class y{constructor(a){Object.assign(this,a)}}let z=class{};class A extends z{}let B=(a,b)=>((a,b)=>{let c,d={},e={};for(c in a)c in b?d[c]=a[c]:e[c]=a[c];return[d,e]})(a,b)[1],C=a=>0===Object.keys(a).length,D=a=>[...Object.entries(a),...Object.getOwnPropertySymbols(a).map(b=>[b,a[b]])],E=v(`unset\u{200B}`),F={Array,Boolean,Date,Error,Function,Map,Number,Promise,RegExp,Set,String,WeakMap,WeakSet},G=globalThis.File??Blob,H={ArrayBuffer,Blob,File:G,FormData,Headers,Request,Response,URL},I={...F,...H,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array,String,Number,Boolean},J=a=>{let b=Object.getPrototypeOf(a);for(;b?.constructor&&(!x(b.constructor.name,I)||!(a instanceof I[b.constructor.name]));)b=Object.getPrototypeOf(b);let c=b?.constructor?.name;if(void 0!==c&&"Object"!==c)return c},K=a=>"object"==typeof a&&null!==a?J(a)??"object":n(a),L=Array.isArray,M={Array:"an array",Function:"a function",Date:"a Date",RegExp:"a RegExp",Error:"an Error",Map:"a Map",Set:"a Set",String:"a String object",Number:"a Number object",Boolean:"a Boolean object",Promise:"a Promise",WeakMap:"a WeakMap",WeakSet:"a WeakSet",ArrayBuffer:"an ArrayBuffer instance",Blob:"a Blob instance",File:"a File instance",FormData:"a FormData instance",Headers:"a Headers instance",Request:"a Request instance",Response:"a Response instance",URL:"a URL instance",Int8Array:"an Int8Array",Uint8Array:"a Uint8Array",Uint8ClampedArray:"a Uint8ClampedArray",Int16Array:"an Int16Array",Uint16Array:"a Uint16Array",Int32Array:"an Int32Array",Uint32Array:"a Uint32Array",Float32Array:"a Float32Array",Float64Array:"a Float64Array",BigInt64Array:"a BigInt64Array",BigUint64Array:"a BigUint64Array"},N=a=>{let b=Object(a).name??null;return b&&x(b,I)&&I[b]===a?b:null},O=(a,b)=>{let c=a.prototype;for(;null!==c;){if(c===b.prototype)return!0;c=Object.getPrototypeOf(c)}return!1},P=(a,b)=>{if("object"!=typeof a||null===a)return a;if(b?.has(a))return b.get(a);let c=N(a.constructor);if("Date"===c)return new Date(a.getTime());if(c&&"Array"!==c)return a;let d=Array.isArray(a)?a.slice():Object.create(Object.getPrototypeOf(a)),e=Object.getOwnPropertyDescriptors(a);if(b)for(let c in b.set(a,d),e){let a=e[c];"get"in a||"set"in a||(a.value=P(a.value,b))}return Object.defineProperties(d,e),d},Q=(a,b)=>{let c={},d=Array.isArray(a),e=!1;for(let[f,g]of Object.entries(a).entries()){let a=d?b(f,g[1]):b(...g,f);for(let[b,d]of(e||="number"==typeof a[0],Array.isArray(a[0])||0===a.length?a:[a]))"object"==typeof b?c[b.group]=i(c[b.group],d):c[b]=d}return e?Object.values(c):c},R=a=>"function"==typeof a&&0===a.length,S=class extends Function{constructor(...a){let b=a.slice(0,-1),c=a[a.length-1];try{super(...b,c)}catch(b){return r(`Encountered an unexpected error while compiling your definition:
                Message: ${b} 
                Source: (${a.slice(0,-1)}) => {
                    ${a[a.length-1]}
                }`)}}};class T{constructor(a,...[b]){return Object.assign(Object.setPrototypeOf(a.bind(b?.bind??this),this.constructor.prototype),b?.attach)}}let U=(a=>{let b=E;return()=>b===E?b=a():b})(()=>{try{return Function("return false")()}catch{return!0}});v("brand"),v("arkInferred"),v("args");class V{constructor(){}}let W=globalThis.process?.env??{},X=a=>new RegExp(Y(a),"string"==typeof a?"":a.flags),Y=a=>{let b="string"==typeof a?a:a.source;return`^(?:${b})$`},Z={negativeLookahead:a=>`(?!${a})`,nonCapturingGroup:a=>`(?:${a})`},$={" ":1,"\n":1,"	":1},_=/^-0\.?0*$/.source,aa=/[1-9]\d*/.source,ab=/\.\d+/.source,ac=/\.\d*[1-9]/.source,ad=a=>X(Z.negativeLookahead(_)+Z.nonCapturingGroup("-?"+Z.nonCapturingGroup(Z.nonCapturingGroup("0|"+aa)+Z.nonCapturingGroup(a.decimalPattern)+"?")+(a.allowDecimalOnly?"|"+a.decimalPattern:"")+"?")),ae=ad({decimalPattern:ac,allowDecimalOnly:!1}),af=ae.test.bind(ae),ag=ad({decimalPattern:ab,allowDecimalOnly:!0});ag.test.bind(ag);let ah=/^-?\d*\.?\d*$/,ai=X(Z.negativeLookahead("^-0$")+"-?"+Z.nonCapturingGroup(Z.nonCapturingGroup("0|"+aa))),aj=ai.test.bind(ai),ak=/^-?\d+$/,al=ak.test.bind(ak),am={number:"a number",bigint:"a bigint",integer:"an integer"},an=(a,b)=>`'${a}' was parsed as ${am[b]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`,ao=(a,b,c)=>{let d=((a,b)=>"number"===b?Number(a):Number.parseInt(a))(a,b);return!Number.isNaN(d)&&((a,b)=>"number"===b?(a=>0!==a.length&&ah.test(a))(a):al(a))(a,b)?c?.strict?((a,b)=>"number"===b?af(a):aj(a))(a,b)?d:u(an(a,b)):d:c?.errorOnFail?u(c?.errorOnFail===!0?`Failed to parse ${am[b]} from '${a}'`:c?.errorOnFail):void 0},ap={version:"0.55.0",filename:({fileName:()=>{try{let a=Error(),b=a.stack?.split("\n")[2]?.trim()||"";return(b.match(/\(?(.+?)(?::\d+:\d+)?\)?$/)?.[1]||"unknown").replace(/^file:\/\//,"")}catch{return"unknown"}},env:W}).fileName(),FileConstructor:G},aq=new Map,ar=Object.create(null),as=a=>{let b=aq.get(a);if(b)return b;let c=au(a);return ar[c]?c=`${c}${ar[c]++}`:ar[c]=1,ap[c]=a,aq.set(a,c),c},at=a=>/^[$A-Z_a-z][\w$]*$/.test(a),au=a=>{switch(typeof a){case"object":{if(null===a)break;let b=J(a)??"object";return b[0].toLowerCase()+b.slice(1)}case"function":return at(a.name)?a.name:"fn";case"symbol":return a.description&&at(a.description)?a.description:"symbol"}return r(`Unexpected attempt to register serializable value of type ${n(a)}`)},av=a=>"string"==typeof a?JSON.stringify(a):"bigint"==typeof a?`${a}n`:`${a}`,aw=(a,b)=>{switch(n(a)){case"object":let c=a.constructor.name;return"Object"===c||"Array"===c?b?.quoteKeys===!1?ax(a,b?.indent??0,""):JSON.stringify(az(a,ay,[]),null,b?.indent):ax(a,b?.indent??0,"");case"symbol":return ay.onSymbol(a);default:return av(a)}},ax=(a,b,c)=>{if("function"==typeof a)return ay.onFunction(a);if("object"!=typeof a||null===a)return av(a);let d=c+" ".repeat(b);if(Array.isArray(a)){if(0===a.length)return"[]";let e=a.map(a=>ax(a,b,d)).join(",\n"+d);return b?`[
${d}${e}
${c}]`:`[${e}]`}let e=a.constructor.name;if("Object"===e){let e=D(a).map(([a,c])=>{let e="symbol"==typeof a?ay.onSymbol(a):at(a)?a:JSON.stringify(a),f=ax(c,b,d);return`${d}${e}: ${f}`});return 0===e.length?"{}":b?`{
${e.join(",\n")}
${c}}`:`{${e.join(", ")}}`}return a instanceof Date?aA(a):"expression"in a&&"string"==typeof a.expression?a.expression:e},ay={onCycle:()=>"(cycle)",onSymbol:a=>`Symbol(${as(a)})`,onFunction:a=>`Function(${as(a)})`},az=(a,b,c)=>{switch(n(a)){case"object":{if("toJSON"in a&&"function"==typeof a.toJSON)return a.toJSON();if("function"==typeof a)return ay.onFunction(a);if(c.includes(a))return"(cycle)";let d=[...c,a];if(Array.isArray(a))return a.map(a=>az(a,b,d));if(a instanceof Date)return a.toDateString();let e={};for(let c in a)e[c]=az(a[c],b,d);for(let c of Object.getOwnPropertySymbols(a))e[b.onSymbol?.(c)??c.toString()]=az(a[c],b,d);return e}case"symbol":return ay.onSymbol(a);case"bigint":return b.onBigInt?.(a)??`${a}n`;case"undefined":return b.onUndefined??"undefined";case"string":return a.replace(/\\/g,"\\\\");default:return a}},aA=a=>{let b=a.getFullYear(),c=a.getMonth(),d=a.getDate(),e=a.getHours(),f=a.getMinutes(),g=a.getSeconds(),h=a.getMilliseconds();if(0===c&&1===d&&0===e&&0===f&&0===g&&0===h)return`${b}`;let i=`${aB[c]} ${d}, ${b}`;if(0===e&&0===f&&0===g&&0===h)return i;let j=a.toLocaleTimeString(),k=j.endsWith(" AM")||j.endsWith(" PM")?j.slice(-3):"";return k&&(j=j.slice(0,-k.length)),h?j+=`.${aD(h,3)}`:aC.test(j)&&(j=j.slice(0,-3)),`${j+k}, ${i}`},aB=["January","February","March","April","May","June","July","August","September","October","November","December"],aC=/:\d\d:00$/,aD=(a,b)=>String(a).padStart(b,"0"),aE=(a,b,...[c])=>{let d=c?.stringifySymbol??aw,e=a;switch(typeof b){case"string":e=at(b)?""===a?b:`${a}.${b}`:`${a}[${JSON.stringify(b)}]`;break;case"number":e=`${a}[${b}]`;break;case"symbol":e=`${a}[${d(b)}]`;break;default:c?.stringifyNonKey?e=`${a}[${c.stringifyNonKey(b)}]`:u(`${aw(b)} must be a PropertyKey or stringifyNonKey must be passed to options`)}return e},aF=(a,...b)=>a.reduce((a,c)=>aE(a,c,...b),"");class aG extends f{cache={};constructor(...a){super(),this.push(...a)}toJSON(){if(this.cache.json)return this.cache.json;this.cache.json=[];for(let a=0;a<this.length;a++)this.cache.json.push("symbol"==typeof this[a]?aw(this[a]):this[a]);return this.cache.json}stringify(){return this.cache.stringify?this.cache.stringify:this.cache.stringify=aF(this)}stringifyAncestors(){if(this.cache.stringifyAncestors)return this.cache.stringifyAncestors;let a="",b=[a];for(let c of this)a=aE(a,c),b.push(a);return this.cache.stringifyAncestors=b}}class aH{chars;i;def;constructor(a){this.def=a,this.chars=[...a],this.i=0}shift(){return this.chars[this.i++]??""}get lookahead(){return this.chars[this.i]??""}get nextLookahead(){return this.chars[this.i+1]??""}get length(){return this.chars.length}shiftUntil(a){let b="";for(;this.lookahead;)if(a(this,b))break;else b+=this.shift();return b}shiftUntilEscapable(a){let b="";for(;this.lookahead;)if("\\"===this.lookahead)this.shift(),a(this,b)||"\\"===this.lookahead?b+=this.shift():b+=`\\${this.shift()}`;else if(a(this,b))break;else b+=this.shift();return b}shiftUntilLookahead(a){return"string"==typeof a?this.shiftUntil(b=>b.lookahead===a):this.shiftUntil(b=>b.lookahead in a)}shiftUntilNonWhitespace(){return this.shiftUntil(()=>!(this.lookahead in $))}jumpToIndex(a){this.i=a<0?this.length+a:a}jumpForward(a){this.i+=a}get location(){return this.i}get unscanned(){return this.chars.slice(this.i,this.length).join("")}get scanned(){return this.chars.slice(0,this.i).join("")}sliceChars(a,b){return this.chars.slice(a,b).join("")}lookaheadIs(a){return this.lookahead===a}lookaheadIsIn(a){return this.lookahead in a}}let aI=a=>`Missing ${a}`;v("implementedTraits"),Symbol.hasInstance;let aJ="$ark",aK=2;for(;aJ in globalThis;)aJ=`$ark${aK++}`;let aL=aJ;globalThis[aL]=ap;let aM=a=>{let b;return b=as(a),`${aL}.${b}`};class aN extends A{argNames;body="";constructor(...a){for(let b of(super(),this.argNames=a,a)){if(b in this)throw Error(`Arg name '${b}' would overwrite an existing property on FunctionBody`);this[b]=b}}indentation=0;indent(){return this.indentation+=4,this}dedent(){return this.indentation-=4,this}prop(a,b=!1){return aP(a,b)}index(a,b=!1){return aR(`${a}`,b)}line(a){return this.body+=`${" ".repeat(this.indentation)}${a}
`,this}const(a,b){return this.line(`const ${a} = ${b}`),this}let(a,b){return this.line(`let ${a} = ${b}`)}set(a,b){return this.line(`${a} = ${b}`)}if(a,b){return this.block(`if (${a})`,b)}elseIf(a,b){return this.block(`else if (${a})`,b)}else(a){return this.block("else",a)}for(a,b,c=0){return this.block(`for (let i = ${c}; ${a}; i++)`,b)}forIn(a,b){return this.block(`for (const k in ${a})`,b)}block(a,b,c=""){return this.line(`${a} {`),this.indent(),b(this),this.dedent(),this.line(`}${c}`)}return(a=""){return this.line(`return ${a}`)}write(a="anonymous",b=0){return`${a}(${this.argNames.join(", ")}) { ${b?this.body.split("\n").map(a=>" ".repeat(b)+`${a}`).join("\n"):this.body} }`}compile(){return new S(...this.argNames,this.body)}}let aO=a=>m(a,"object")||"symbol"==typeof a?aM(a):av(a),aP=(a,b=!1)=>"string"==typeof a&&at(a)?`${b?"?":""}.${a}`:aR(aQ(a),b),aQ=a=>"symbol"==typeof a?aM(a):JSON.stringify(a),aR=(a,b=!1)=>`${b?"?.":""}[${a}]`;class aS extends aN{traversalKind;optimistic;constructor(a){super("data","ctx"),this.traversalKind=a.kind,this.optimistic=!0===a.optimistic}invoke(a,b){let c=b?.arg??this.data,d="string"==typeof a||this.requiresContextFor(a),e="string"==typeof a?a:a.id;return d?`${this.referenceToId(e,b)}(${c}, ${this.ctx})`:`${this.referenceToId(e,b)}(${c})`}referenceToId(a,b){let c=b?.kind??this.traversalKind,d=`this.${a}${c}`;return b?.bind?`${d}.bind(${b?.bind})`:d}requiresContextFor(a){return"Apply"===this.traversalKind||a.allowsRequiresContext}initializeErrorCount(){return this.const("errorCount","ctx.currentErrorCount")}returnIfFail(){return this.if("ctx.currentErrorCount > errorCount",()=>this.return())}returnIfFailFast(){return this.if("ctx.failFast && ctx.currentErrorCount > errorCount",()=>this.return())}traverseKey(a,b,c){let d=this.requiresContextFor(c);return d&&this.line(`${this.ctx}.path.push(${a})`),this.check(c,{arg:b}),d&&this.line(`${this.ctx}.path.pop()`),this}check(a,b){return"Allows"===this.traversalKind?this.if(`!${this.invoke(a,b)}`,()=>this.return(!1)):this.line(this.invoke(a,b))}}let aT=a=>Q(a,(a,b)=>[a,L(b)?[...b]:b]),aU=v("arkKind"),aV=(a,b)=>a?.[aU]===b,aW=a=>aV(a,"root")||aV(a,"constraint"),aX=["unit","proto","domain"],aY=["required","optional","index","sequence"],aZ=["pattern","divisor","exactLength","max","min","maxLength","minLength","before","after"],a$=[...aZ,"structure","predicate"],a_=[...a$,...aY],a0=["alias","union","morph","unit","intersection","proto","domain"],a1=[...a0,...a_],a2=Q(a_,(a,b)=>[b,1]),a3=Q([...aY,"undeclared"],(a,b)=>[b,1]),a4=Q(a1,(a,b)=>[b,a]),a5=a=>"string"==typeof a&&a in a4,a6=a=>a4[a],a7=a=>a0.slice(a6(a)+1);[...a7("union")],[...a7("morph")];let a8=a=>"string"==typeof a||"boolean"==typeof a||null===a?a:"number"==typeof a?Number.isNaN(a)?"NaN":a===1/0?"Infinity":a===-1/0?"-Infinity":a:aO(a),a9=a=>{let b="{ ";for(let[c,d]of Object.entries(a))b+=`${c}: ${aO(d)}, `;return b+" }"},ba=a=>(a.hasAssociatedError&&(a.defaults.expected??=b=>"description"in b?b.description:a.defaults.description(b),a.defaults.actual??=a=>aw(a),a.defaults.problem??=a=>`must be ${a.expected}${a.actual?` (was ${a.actual})`:""}`,a.defaults.message??=a=>{if(0===a.path.length)return a.problem;let b=`${a.propString} ${a.problem}`;return"["===b[0]?`value at ${b}`:b}),a);class bb extends Error{name="ToJsonSchemaError";code;context;constructor(a,b){super(aw(b,{quoteKeys:!1,indent:4})),this.code=a,this.context=b}hasCode(a){return this.code===a}}let bc={Error:bb,throw:(...a)=>{throw new bc.Error(...a)},throwInternalOperandError:(a,b)=>r(`Unexpected JSON Schema input for ${a}: ${aw(b)}`),defaultConfig:{dialect:"https://json-schema.org/draft/2020-12/schema",useRefs:!1,fallback:{arrayObject:a=>bc.throw("arrayObject",a),arrayPostfix:a=>bc.throw("arrayPostfix",a),defaultValue:a=>bc.throw("defaultValue",a),domain:a=>bc.throw("domain",a),morph:a=>bc.throw("morph",a),patternIntersection:a=>bc.throw("patternIntersection",a),predicate:a=>bc.throw("predicate",a),proto:a=>bc.throw("proto",a),symbolKey:a=>bc.throw("symbolKey",a),unit:a=>bc.throw("unit",a),date:a=>bc.throw("date",a)}}};ap.config??={};let bd=(a,b)=>{let c;if(!b)return a;let d={...a};for(c in b){let e={...a.keywords};if("keywords"===c){for(let a in b[c]){let c=b.keywords[a];void 0!==c&&(e[a]="string"==typeof c?{description:c}:c)}d.keywords=e}else"toJsonSchema"===c?d[c]=be(a.toJsonSchema,b.toJsonSchema):a5(c)?d[c]={...a[c],...b[c]}:d[c]=b[c]}return d},be=(a,b)=>{let c;if(!a)return b??{};if(!b)return a;let d={...a};for(c in b)"fallback"===c?d.fallback=bf(a.fallback,b.fallback):d[c]=b[c];return d},bf=(a,b)=>{let c;a=bg(a),b=bg(b);let d={};for(c in bc.defaultConfig.fallback)d[c]=b[c]??b.default??a[c]??a.default??bc.defaultConfig.fallback[c];return d},bg=a=>"function"==typeof a?{default:a}:a??{};class bh extends A{[aU]="error";path;data;nodeConfig;input;ctx;constructor({prefixPath:a,relativePath:b,...c},d){super(),this.input=c,this.ctx=d,Object.defineProperties(this,Object.getOwnPropertyDescriptors(c));let e=d.data;"union"===c.code&&(c.errors=c.errors.flatMap(c=>{let d=c.hasCode("union")?c.errors:[c];return a||b?d.map(c=>c.transform(c=>({...c,path:((...a)=>a.reduce(j,[]))(a,c.path,b)}))):d})),this.nodeConfig=d.config[this.code];let f=[...c.path??d.path];b&&f.push(...b),a&&f.unshift(...a),this.path=new aG(...f),this.data="data"in c?c.data:e}transform(a){return new bh(a({data:this.data,path:this.path,...this.input}),this.ctx)}hasCode(a){return this.code===a}get propString(){return aF(this.path)}get expected(){if(this.input.expected)return this.input.expected;let a=this.meta?.expected??this.nodeConfig.expected;return"function"==typeof a?a(this.input):a}get actual(){if(this.input.actual)return this.input.actual;let a=this.meta?.actual??this.nodeConfig.actual;return"function"==typeof a?a(this.data):a}get problem(){if(this.input.problem)return this.input.problem;let a=this.meta?.problem??this.nodeConfig.problem;return"function"==typeof a?a(this):a}get message(){if(this.input.message)return this.input.message;let a=this.meta?.message??this.nodeConfig.message;return"function"==typeof a?a(this):a}get flat(){return this.hasCode("intersection")?[...this.errors]:[this]}toJSON(){return{data:this.data,path:this.path,...this.input,expected:this.expected,actual:this.actual,problem:this.problem,message:this.message}}toString(){return this.message}throw(){throw this}}class bi extends f{[aU]="errors";ctx;constructor(a){super(),this.ctx=a}byPath=Object.create(null);get flatByPath(){return Q(this.byPath,(a,b)=>[a,b.flat])}get flatProblemsByPath(){return Q(this.byPath,(a,b)=>[a,b.flat.map(a=>a.problem)])}byAncestorPath=Object.create(null);count=0;mutable=this;throw(){throw this.toTraversalError()}toTraversalError(){return new bj(this)}add(a){let b=this.byPath[a.propString];if(b){if(a===b||b.hasCode("union")&&0===b.errors.length)return;let c=a.hasCode("union")&&0===a.errors.length?a:new bh({code:"intersection",errors:b.hasCode("intersection")?[...b.errors,a]:[b,a]},this.ctx),d=this.indexOf(b);this.mutable[-1===d?this.length:d]=c,this.byPath[a.propString]=c,this.addAncestorPaths(a)}else this.byPath[a.propString]=a,this.addAncestorPaths(a),this.mutable.push(a);this.count++}transform(a){let b=new bi(this.ctx);for(let c of this)b.add(a(c));return b}merge(a){for(let b of a)this.add(new bh({...b,path:[...this.ctx.path,...b.path]},this.ctx))}affectsPath(a){return 0!==this.length&&(a.stringifyAncestors().some(a=>a in this.byPath)||a.stringify()in this.byAncestorPath)}get summary(){return this.toString()}get issues(){return this}toJSON(){return[...this.map(a=>a.toJSON())]}toString(){return this.join("\n")}addAncestorPaths(a){for(let b of a.path.stringifyAncestors())this.byAncestorPath[b]=i(this.byAncestorPath[b],a)}}class bj extends Error{name="TraversalError";constructor(a){1===a.length?super(a.summary):super("\n"+a.map(a=>`  • ${bk(a)}`).join("\n")),Object.defineProperty(this,"arkErrors",{value:a,enumerable:!1})}}let bk=a=>a.toString().split("\n").join("\n  ");class bl{path=[];errors=new bi(this);root;config;queuedMorphs=[];branches=[];seen={};constructor(a,b){this.root=a,this.config=b}get data(){let a=this.root;for(let b of this.path)a=a?.[b];return a}get propString(){return aF(this.path)}reject(a){return this.error(a),!1}mustBe(a){return this.error(a),!1}error(a){let b="object"==typeof a?a.code?a:{...a,code:"predicate"}:{code:"predicate",expected:a};return this.errorFromContext(b)}hasError(){return 0!==this.currentErrorCount}get currentBranch(){return this.branches[this.branches.length-1]}queueMorphs(a){let b={path:new aG(...this.path),morphs:a};this.currentBranch?this.currentBranch.queuedMorphs.push(b):this.queuedMorphs.push(b)}finalize(a){return(this.queuedMorphs.length&&("object"==typeof this.root&&null!==this.root&&this.config.clone&&(this.root=this.config.clone(this.root)),this.applyQueuedMorphs()),this.hasError())?a?a(this.errors):this.errors:this.root}get currentErrorCount(){return this.currentBranch?+!!this.currentBranch.error:this.errors.count}get failFast(){return 0!==this.branches.length}pushBranch(){this.branches.push({error:void 0,queuedMorphs:[]})}popBranch(){return this.branches.pop()}get external(){return this}errorFromNodeContext(a){return this.errorFromContext(a)}errorFromContext(a){let b=new bh(a,this);return this.currentBranch?this.currentBranch.error=b:this.errors.add(b),b}applyQueuedMorphs(){for(;this.queuedMorphs.length;){let a=this.queuedMorphs;for(let{path:b,morphs:c}of(this.queuedMorphs=[],a))this.errors.affectsPath(b)||this.applyMorphsAtPath(b,c)}}applyMorphsAtPath(a,b){let c,d=a[a.length-1];if(void 0!==d){c=this.root;for(let b=0;b<a.length-1;b++)c=c[a[b]]}for(let e of b){this.path=[...a];let b=aW(e),f=e(void 0===c?this.root:c[d],this);if(f instanceof bh){this.errors.add(f);break}if(f instanceof bi){b||this.errors.merge(f),this.queuedMorphs=[];break}void 0===c?this.root=f:c[d]=f,this.applyQueuedMorphs()}}}let bm=(a,b,c)=>{if(!c)return b();c.path.push(a);let d=b();return c.path.pop(),d};class bn extends T{attachments;$;onFail;includesTransform;includesContextualPredicate;isCyclic;allowsRequiresContext;rootApplyStrategy;contextFreeMorph;rootApply;referencesById;shallowReferences;flatRefs;flatMorphs;allows;get shallowMorphs(){return[]}constructor(a,b){super((a,b,c=this.onFail)=>b?(this.traverseApply(a,b),b.hasError()?b.errors:b.data):this.rootApply(a,c),{attach:a}),this.attachments=a,this.$=b,this.onFail=this.meta.onFail??this.$.resolvedConfig.onFail,this.includesTransform=this.hasKind("morph")||this.hasKind("structure")&&void 0!==this.structuralMorph||this.hasKind("sequence")&&void 0!==this.inner.defaultables,this.includesContextualPredicate=this.hasKind("predicate")&&1!==this.inner.predicate.length,this.isCyclic="alias"===this.kind,this.referencesById={[this.id]:this},this.shallowReferences=this.hasKind("structure")?[this,...this.children]:this.children.reduce((a,b)=>bv(a,b.shallowReferences),[this]);let c=this.isStructural();this.flatRefs=[],this.flatMorphs=[];for(let a=0;a<this.children.length;a++){if(this.includesTransform||=this.children[a].includesTransform,this.includesContextualPredicate||=this.children[a].includesContextualPredicate,this.isCyclic||=this.children[a].isCyclic,!c){let b=this.children[a].flatRefs;for(let a=0;a<b.length;a++){let c=b[a];if(!this.flatRefs.some(a=>bt(a,c)))for(let a of(this.flatRefs.push(c),c.node.branches))(a.hasKind("morph")||a.hasKind("intersection")&&a.structure?.structuralMorph!==void 0)&&this.flatMorphs.push({path:c.path,propString:c.propString,node:a})}}Object.assign(this.referencesById,this.children[a].referencesById)}this.flatRefs.sort((a,b)=>a.path.length>b.path.length?1:a.path.length<b.path.length?-1:a.propString>b.propString?1:a.propString<b.propString||a.node.expression<b.node.expression?-1:1),this.allowsRequiresContext=this.includesContextualPredicate||this.isCyclic,this.rootApplyStrategy=this.allowsRequiresContext||0!==this.flatMorphs.length?"contextual":0===this.shallowMorphs.length?"allows":this.shallowMorphs.every(a=>1===a.length||"$arkStructuralMorph"===a.name)?this.hasKind("union")?this.branches.some(a=>a.shallowMorphs.length>1)?"contextual":"branchedOptimistic":this.shallowMorphs.length>1?"contextual":"optimistic":"contextual",this.rootApply=this.createRootApply(),this.allows=this.allowsRequiresContext?a=>this.traverseAllows(a,new bl(a,this.$.resolvedConfig)):a=>this.traverseAllows(a)}createRootApply(){switch(this.rootApplyStrategy){case"allows":return(a,b)=>{if(this.allows(a))return a;let c=new bl(a,this.$.resolvedConfig);return this.traverseApply(a,c),c.finalize(b)};case"contextual":return(a,b)=>{let c=new bl(a,this.$.resolvedConfig);return this.traverseApply(a,c),c.finalize(b)};case"optimistic":this.contextFreeMorph=this.shallowMorphs[0];let a=this.$.resolvedConfig.clone;return(b,c)=>{if(this.allows(b))return this.contextFreeMorph(a&&("object"==typeof b&&null!==b||"function"==typeof b)?a(b):b);let d=new bl(b,this.$.resolvedConfig);return this.traverseApply(b,d),d.finalize(c)};case"branchedOptimistic":return this.createBranchedOptimisticRootApply();default:return this.rootApplyStrategy,r(`Unexpected rootApplyStrategy ${this.rootApplyStrategy}`)}}compiledMeta=br(this.metaJson);cacheGetter(a,b){return Object.defineProperty(this,a,{value:b}),b}get description(){return this.cacheGetter("description",this.meta?.description??this.$.resolvedConfig[this.kind].description(this))}get references(){return Object.values(this.referencesById)}precedence=a6(this.kind);precompilation;assert=(a,b)=>this(a,b,a=>a.throw());traverse(a,b){return this(a,b,null)}get in(){return this.cacheGetter("in",this.rawIn.isRoot()?this.$.finalize(this.rawIn):this.rawIn)}get rawIn(){return this.cacheGetter("rawIn",this.getIo("in"))}get out(){return this.cacheGetter("out",this.rawOut.isRoot()?this.$.finalize(this.rawOut):this.rawOut)}get rawOut(){return this.cacheGetter("rawOut",this.getIo("out"))}getIo(a){if(!this.includesTransform)return this;let b={};for(let[c,d]of this.innerEntries){let e=this.impl.keys[c];e.reduceIo?e.reduceIo(a,b,d):e.child?b[c]=L(d)?d.map(b=>"in"===a?b.rawIn:b.rawOut):"in"===a?d.rawIn:d.rawOut:b[c]=d}return this.$.node(this.kind,b)}toJSON(){return this.json}toString(){return`Type<${this.expression}>`}equals(a){let b=aW(a)?a:this.$.parseDefinition(a);return this.innerHash===b.innerHash}ifEquals(a){return this.equals(a)?this:void 0}hasKind(a){return this.kind===a}assertHasKind(a){return this.kind!==a&&s(`${this.kind} node was not of asserted kind ${a}`),this}hasKindIn(...a){return a.includes(this.kind)}assertHasKindIn(...a){return g(a,this.kind)||s(`${this.kind} node was not one of asserted kinds ${a}`),this}isBasis(){return g(aX,this.kind)}isConstraint(){return g(a_,this.kind)}isStructural(){return g(aY,this.kind)}isRefinement(){return g(a$,this.kind)}isRoot(){return g(a0,this.kind)}isUnknown(){return this.hasKind("intersection")&&0===this.children.length}isNever(){return this.hasKind("union")&&0===this.children.length}hasUnit(a){return this.hasKind("unit")&&this.allows(a)}hasOpenIntersection(){return this.impl.intersectionIsOpen}get nestableExpression(){return this.expression}select(a){let b=bo.normalize(a);return this._select(b)}_select(a){let b=bo.applyBoundary[a.boundary??"references"](this);return a.kind&&(b=b.filter(b=>b.kind===a.kind)),a.where&&(b=b.filter(a.where)),bo.applyMethod[a.method??"filter"](b,this,a)}transform(a,b){return this._transform(a,this._createTransformContext(b))}_createTransformContext(a){return{root:this,selected:void 0,seen:{},path:[],parseOptions:{prereduced:a?.prereduced??!1},undeclaredKeyHandling:void 0,...a}}_transform(a,b){let c,d=b.bindScope??this.$;if(b.seen[this.id])return this.$.lazilyResolve(b.seen[this.id]);if(b.shouldTransform?.(this,b)===!1)return this;b.seen[this.id]=()=>c,this.hasKind("structure")&&this.undeclared!==b.undeclaredKeyHandling&&(b={...b,undeclaredKeyHandling:this.undeclared});let e=Q(this.inner,(c,d)=>{if(!this.impl.keys[c].child)return[c,d];if(!L(d)){let e=d._transform(a,b);return e?[c,e]:[]}if(0===d.length)return[c,d];let e=d.flatMap(c=>c._transform(a,b)??[]);return e.length?[c,e]:[]});delete b.seen[this.id];let f=Object.assign(e,{meta:this.meta}),g=b.selected&&!b.selected.includes(this)?f:a(this.kind,f,b);if(null===g)return null;if(aW(g))return c=g;let h=Object.keys(g);return 0!==h.length&&(1!==h.length||"meta"!==h[0])||C(this.inner)?"required"!==this.kind&&"optional"!==this.kind&&"index"!==this.kind||"value"in g?("morph"===this.kind&&(g.in??=ap.intrinsic.unknown),c=d.node(this.kind,g,b.parseOptions)):b.undeclaredKeyHandling?{...g,value:ap.intrinsic.unknown}:null:null}configureReferences(a,b="references"){let c=bo.normalize(b),d="string"==typeof a?(b,c)=>({...c,meta:{...c.meta,description:a}}):"function"==typeof a?(b,c)=>({...c,meta:a(c.meta)}):(b,c)=>({...c,meta:{...c.meta,...a}});if("self"===c.boundary)return this.$.node(this.kind,d(this.kind,{...this.inner,meta:this.meta}));let f=this._select(c),g=f&&e(f),h="child"===c.boundary?(a,b)=>b.root.children.includes(a):"shallow"===c.boundary?a=>"structure"!==a.kind:()=>!0;return this.$.finalize(this.transform(d,{shouldTransform:h,selected:g}))}}let bo={applyBoundary:{self:a=>[a],child:a=>[...a.children],shallow:a=>[...a.shallowReferences],references:a=>[...a.references]},applyMethod:{filter:a=>a,assertFilter:(a,b,c)=>(0===a.length&&s(bp(b,c)),a),find:a=>a[0],assertFind:(a,b,c)=>(0===a.length&&s(bp(b,c)),a[0])},normalize:a=>"function"==typeof a?{boundary:"references",method:"filter",where:a}:"string"==typeof a?x(a,bo.applyBoundary)?{method:"filter",boundary:a}:{boundary:"references",method:"filter",kind:a}:{boundary:"references",method:"filter",...a}},bp=(a,b)=>`${a} had no references matching ${aw(b)}.`,bq=/"(\$ark\.[^"]+)"/g,br=a=>JSON.stringify(a).replace(bq,"$1"),bs=(a,b)=>({path:a,node:b,propString:aF(a,{stringifyNonKey:a=>a.expression})}),bt=(a,b)=>a.propString===b.propString&&a.node.equals(b.node),bu=(a,b)=>k(a,b,{isEqual:bt}),bv=(a,b)=>k(a,b,{isEqual:(a,b)=>a.equals(b)});class bw extends Array{static init(a,b,c,d){return new bw({kind:a,l:b,r:c,path:d?.path??[],optional:d?.optional??!1})}add(a,b,c,d){return this.push({kind:a,l:b,r:c,path:d?.path??[],optional:d?.optional??!1}),this}get summary(){return this.describeReasons()}describeReasons(){if(1===this.length){let{path:a,l:b,r:c}=this[0],d=aF(a);return bz(`Intersection${d&&` at ${d}`} of ${bx(b,c)}`)}return`The following intersections result in unsatisfiable types:
• ${this.map(({path:a,l:b,r:c})=>`${a}: ${bx(b,c)}`).join("\n• ")}`}throw(){return u(this.describeReasons())}invert(){let a=this.map(a=>({...a,l:a.r,r:a.l}));return a instanceof bw?a:new bw(...a)}withPrefixKey(a,b){return this.map(c=>({...c,path:[a,...c.path],optional:c.optional||"optional"===b}))}toNeverIfDisjoint(){return ap.intrinsic.never}}let bx=(a,b)=>`${by(a)} and ${by(b)}`,by=a=>aW(a)?a.expression:L(a)?a.map(by).join(" | ")||"never":String(a),bz=a=>`${a} results in an unsatisfiable type`,bA={},bB=(a,b,c)=>bD(a,b,{$:c,invert:!1,pipe:!1}),bC=(a,b,c)=>bD(a,b,{$:c,invert:!1,pipe:!0}),bD=(a,b,c)=>{let d=c.pipe?"|>":"&",e=`${a.hash}${d}${b.hash}`;if(void 0!==bA[e])return bA[e];if(!c.pipe){let c=`${b.hash}${d}${a.hash}`;if(void 0!==bA[c]){let a=bA[c],b=a instanceof bw?a.invert():a;return bA[e]=b,b}}let f=!c.pipe||!a.includesTransform&&!b.includesTransform;if(f&&a.equals(b))return a;let g=f?bE(a,b,c):a.hasKindIn(...a0)?bF(a,b,c):bE(a,b,c);return aW(g)&&(a.equals(g)?g=a:b.equals(g)&&(g=b)),bA[e]=g,g},bE=(a,b,c)=>{let d=a.precedence<b.precedence?a.kind:b.kind,e=a.impl.intersections[b.kind]??b.impl.intersections[a.kind];if(void 0===e)return null;{if(d===a.kind)return e(a,b,c);let f=e(b,a,{...c,invert:!c.invert});return f instanceof bw&&(f=f.invert()),f}},bF=(a,b,c)=>a.includesTransform||b.includesTransform?c.invert?bG(b,a,c):bG(a,b,c):bE(a,b,c),bG=(a,b,c)=>a.distribute(a=>bH(a,b,c),d=>{let e,f=d.filter(aW);if(0===f.length)return bw.init("union",a.branches,b.branches);if(f.length<a.branches.length||!a.branches.every((a,b)=>a.rawIn.equals(f[b].rawIn)))return c.$.parseSchema(f);if(1===f.length){let a=f[0];return e?c.$.node("morph",{...a.inner,in:a.rawIn.configure(e,"self")}):a}let g={branches:f};return e&&(g.meta=e),c.$.parseSchema(g)}),bH=(a,b,c)=>{if(a.hasKind("morph")){let d=[...a.morphs];if(a.lastMorphIfNode){let e=bD(a.lastMorphIfNode,b,c);if(e instanceof bw)return e;d[d.length-1]=e}else d.push(b);return c.$.node("morph",{morphs:d,in:a.inner.in})}if(b.hasKind("morph")){let d=bD(a,b.rawIn,c);return d instanceof bw?d:c.$.node("morph",{morphs:[b],in:d})}return c.$.node("morph",{morphs:[b],in:a})};class bI extends bn{constructor(a,b){super(a,b),Object.defineProperty(this,aU,{value:"constraint",enumerable:!1})}impliedSiblings;intersect(a){return bB(this,a,this.$)}}class bJ extends bI{traverseApply=(a,b)=>{this.traverseAllows(a,b)||b.errorFromNodeContext(this.errorContext)};compile(a){"Allows"===a.traversalKind?a.return(this.compiledCondition):a.if(this.compiledNegation,()=>a.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`))}get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return a9(this.errorContext)}}let bK=a=>(b,c)=>{if(L(b)){if(0===b.length)return;let d=b.map(b=>c.$.node(a,b));return"predicate"===a?d:d.sort((a,b)=>a.hash<b.hash?-1:1)}let d=c.$.node(a,b);return d.hasOpenIntersection()?[d]:d},bL=a=>{let b=a.r.shift();if(!b){let b=0===a.l.length&&"structure"===a.kind?ap.intrinsic.unknown.internal:a.ctx.$.node(a.kind,Object.assign(a.baseInner,bN(a.l)),{prereduced:!0});for(let c of a.roots){if(b instanceof bw)break;b=bD(c,b,a.ctx)}return b}let c=!1;for(let d=0;d<a.l.length;d++){let e=bD(a.l[d],b,a.ctx);if(null!==e){if(e instanceof bw)return e;if(e.isRoot())return a.roots.push(e),a.l.splice(d),bL(a);if(c){if(!a.l.includes(e))return r(`Unexpectedly encountered multiple distinct intersection results for refinement ${b}`)}else a.l[d]=e,c=!0}}if(c||a.l.push(b),"intersection"===a.kind&&b.impliedSiblings)for(let c of b.impliedSiblings)k(a.r,c);return bL(a)},bM=a=>Object.entries(a).flatMap(([a,b])=>a in a2?b:[]).sort((a,b)=>a.precedence<b.precedence?-1:a.precedence>b.precedence?1:"predicate"===a.kind&&"predicate"===b.kind?0:a.hash<b.hash?-1:1),bN=a=>{let b={};for(let c of a)if(c.hasOpenIntersection())b[c.kind]=i(b[c.kind],c);else{if(b[c.kind])return r(`Unexpected intersection of closed refinements of kind ${c.kind}`);b[c.kind]=c}return b};class bO extends T{}class bP extends T{[aU]="generic";paramDefs;bodyDef;$;arg$;baseInstantiation;hkt;description;constructor(a,b,c,d,e){super((...a)=>{let c=Q(this.names,(b,c)=>{let d=this.arg$.parse(a[b]);return d.extends(this.constraints[b])||u(bQ(c,this.constraints[b].expression,d.expression)),[c,d]});if(this.defIsLazy()){let a=this.bodyDef(c);return this.$.parse(a)}return this.$.parse(b,{args:c})}),this.paramDefs=a,this.bodyDef=b,this.$=c,this.arg$=d,this.hkt=e,this.description=e?new e().description??`a generic type for ${e.constructor.name}`:"a generic type",this.baseInstantiation=this(...this.constraints)}defIsLazy(){return this.bodyDef instanceof bO}cacheGetter(a,b){return Object.defineProperty(this,a,{value:b}),b}get json(){return this.cacheGetter("json",{params:this.params.map(a=>a[1].isUnknown()?a[0]:[a[0],a[1].json]),body:((a,b={})=>az(a,{onUndefined:"$ark.undefined",onBigInt:a=>`$ark.bigint-${a}`,...b},[]))(this.bodyDef)})}get params(){return this.cacheGetter("params",this.paramDefs.map(a=>"string"==typeof a?[a,ap.intrinsic.unknown]:[a[0],this.$.parse(a[1])]))}get names(){return this.cacheGetter("names",this.params.map(a=>a[0]))}get constraints(){return this.cacheGetter("constraints",this.params.map(a=>a[1]))}get internal(){return this}get referencesById(){return this.baseInstantiation.internal.referencesById}get references(){return this.baseInstantiation.internal.references}}let bQ=(a,b,c)=>`${a} must be assignable to ${b} (was ${c})`,bR=ba({kind:"predicate",hasAssociatedError:!0,collapsibleKey:"predicate",keys:{predicate:{}},normalize:a=>"function"==typeof a?{predicate:a}:a,defaults:{description:a=>`valid according to ${a.predicate.name||"an anonymous predicate"}`},intersectionIsOpen:!0,intersections:{predicate:()=>null}});class bS extends bI{serializedPredicate=aM(this.predicate);compiledCondition=`${this.serializedPredicate}(data, ctx)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=null;expression=this.serializedPredicate;traverseAllows=this.predicate;errorContext={code:"predicate",description:this.description,meta:this.meta};compiledErrorContext=a9(this.errorContext);traverseApply=(a,b)=>{this.predicate(a,b.external)||b.hasError()||b.errorFromNodeContext(this.errorContext)};compile(a){if("Allows"===a.traversalKind)return void a.return(this.compiledCondition);a.if(`${this.compiledNegation} && !ctx.hasError()`,()=>a.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`))}reduceJsonSchema(a,b){return b.fallback.predicate({code:"predicate",base:a,predicate:this.predicate})}}let bT={implementation:bR,Node:bS},bU=ba({kind:"divisor",collapsibleKey:"rule",keys:{rule:{parse:a=>Number.isInteger(a)?a:u(bX(a))}},normalize:a=>"number"==typeof a?{rule:a}:a,hasAssociatedError:!0,defaults:{description:a=>1===a.rule?"an integer":2===a.rule?"even":`a multiple of ${a.rule}`},intersections:{divisor:(a,b,c)=>c.$.node("divisor",{rule:Math.abs(a.rule*b.rule/bY(a.rule,b.rule))})},obviatesBasisDescription:!0});class bV extends bJ{traverseAllows=a=>a%this.rule==0;compiledCondition=`data % ${this.rule} === 0`;compiledNegation=`data % ${this.rule} !== 0`;impliedBasis=ap.intrinsic.number.internal;expression=`% ${this.rule}`;reduceJsonSchema(a){return a.type="integer",1===this.rule||(a.multipleOf=this.rule),a}}let bW={implementation:bU,Node:bV},bX=a=>`divisor must be an integer (was ${a})`,bY=(a,b)=>{let c,d=a,e=b;for(;0!==e;)c=e,e=d%e,d=c;return d};class bZ extends bJ{boundOperandKind=b5[this.kind];compiledActual="value"===this.boundOperandKind?"data":"length"===this.boundOperandKind?"data.length":"data.valueOf()";comparator=b6(this.kind,this.exclusive);numericLimit=this.rule.valueOf();expression=`${this.comparator} ${this.rule}`;compiledCondition=`${this.compiledActual} ${this.comparator} ${this.numericLimit}`;compiledNegation=`${this.compiledActual} ${b$[this.comparator]} ${this.numericLimit}`;stringLimit="date"===this.boundOperandKind?b7(this.numericLimit):`${this.numericLimit}`;limitKind="<"===this.comparator["0"]?"upper":"lower";isStricterThan(a){return("upper"===this.limitKind?this.numericLimit<a.numericLimit:this.numericLimit>a.numericLimit)||this.numericLimit===a.numericLimit&&!0===this.exclusive&&!a.exclusive}overlapsRange(a){return!this.isStricterThan(a)&&(this.numericLimit!==a.numericLimit||!this.exclusive&&!a.exclusive)}overlapIsUnit(a){return this.numericLimit===a.numericLimit&&!this.exclusive&&!a.exclusive}}let b$={"<":">=","<=":">",">":"<=",">=":"<"},b_={min:"max",minLength:"maxLength",after:"before"},b0={parse:a=>a||void 0},b1=a=>b=>{if("number"==typeof b)return{rule:b};let{exclusive:c,...d}=b;return c?{...d,rule:"minLength"===a?d.rule+1:d.rule-1}:d},b2=a=>b=>{if("number"==typeof b||"string"==typeof b||b instanceof Date)return{rule:b};let{exclusive:c,...d}=b;if(!c)return d;let e="number"==typeof d.rule?d.rule:"string"==typeof d.rule?new Date(d.rule).valueOf():d.rule.valueOf();return c?{...d,rule:"after"===a?e+1:e-1}:d},b3=a=>"string"==typeof a||"number"==typeof a?new Date(a):a,b4=a=>b=>((!Number.isInteger(b)||b<0)&&u(`${a} bound must be a positive integer (was ${b})`),b),b5={min:"value",max:"value",minLength:"length",maxLength:"length",after:"date",before:"date"},b6=(a,b)=>`${x(a,b_)?">":"<"}${b?"":"="}`,b7=a=>"string"==typeof a?a:new Date(a).toLocaleString(),b8=ba({kind:"after",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:b3,serialize:a=>a.toISOString()}},normalize:b2("after"),defaults:{description:a=>`${a.collapsibleLimitString} or later`,actual:aA},intersections:{after:(a,b)=>a.isStricterThan(b)?a:b}});class b9 extends bZ{impliedBasis=ap.intrinsic.Date.internal;collapsibleLimitString=aA(this.rule);traverseAllows=a=>a>=this.rule;reduceJsonSchema(a,b){return b.fallback.date({code:"date",base:a,after:this.rule})}}let ca={implementation:b8,Node:b9},cb=ba({kind:"before",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:b3,serialize:a=>a.toISOString()}},normalize:b2("before"),defaults:{description:a=>`${a.collapsibleLimitString} or earlier`,actual:aA},intersections:{before:(a,b)=>a.isStricterThan(b)?a:b,after:(a,b,c)=>a.overlapsRange(b)?a.overlapIsUnit(b)?c.$.node("unit",{unit:a.rule}):null:bw.init("range",a,b)}});class cc extends bZ{collapsibleLimitString=aA(this.rule);traverseAllows=a=>a<=this.rule;impliedBasis=ap.intrinsic.Date.internal;reduceJsonSchema(a,b){return b.fallback.date({code:"date",base:a,before:this.rule})}}let cd={implementation:cb,Node:cc},ce=ba({kind:"exactLength",collapsibleKey:"rule",keys:{rule:{parse:b4("exactLength")}},normalize:a=>"number"==typeof a?{rule:a}:a,hasAssociatedError:!0,defaults:{description:a=>`exactly length ${a.rule}`,actual:a=>`${a.length}`},intersections:{exactLength:(a,b,c)=>bw.init("unit",c.$.node("unit",{unit:a.rule}),c.$.node("unit",{unit:b.rule}),{path:["length"]}),minLength:(a,b)=>a.rule>=b.rule?a:bw.init("range",a,b),maxLength:(a,b)=>a.rule<=b.rule?a:bw.init("range",a,b)}});class cf extends bJ{traverseAllows=a=>a.length===this.rule;compiledCondition=`data.length === ${this.rule}`;compiledNegation=`data.length !== ${this.rule}`;impliedBasis=ap.intrinsic.lengthBoundable.internal;expression=`== ${this.rule}`;reduceJsonSchema(a){switch(a.type){case"string":return a.minLength=this.rule,a.maxLength=this.rule,a;case"array":return a.minItems=this.rule,a.maxItems=this.rule,a;default:return bc.throwInternalOperandError("exactLength",a)}}}let cg={implementation:ce,Node:cf},ch=ba({kind:"max",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:b0},normalize:a=>"number"==typeof a?{rule:a}:a,defaults:{description:a=>0===a.rule?a.exclusive?"negative":"non-positive":`${a.exclusive?"less than":"at most"} ${a.rule}`},intersections:{max:(a,b)=>a.isStricterThan(b)?a:b,min:(a,b,c)=>a.overlapsRange(b)?a.overlapIsUnit(b)?c.$.node("unit",{unit:a.rule}):null:bw.init("range",a,b)},obviatesBasisDescription:!0});class ci extends bZ{impliedBasis=ap.intrinsic.number.internal;traverseAllows=this.exclusive?a=>a<this.rule:a=>a<=this.rule;reduceJsonSchema(a){return this.exclusive?a.exclusiveMaximum=this.rule:a.maximum=this.rule,a}}let cj={implementation:ch,Node:ci},ck=ba({kind:"maxLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:b4("maxLength")}},reduce:(a,b)=>0===a.rule?b.node("exactLength",a):void 0,normalize:b1("maxLength"),defaults:{description:a=>`at most length ${a.rule}`,actual:a=>`${a.length}`},intersections:{maxLength:(a,b)=>a.isStricterThan(b)?a:b,minLength:(a,b,c)=>a.overlapsRange(b)?a.overlapIsUnit(b)?c.$.node("exactLength",{rule:a.rule}):null:bw.init("range",a,b)}});class cl extends bZ{impliedBasis=ap.intrinsic.lengthBoundable.internal;traverseAllows=a=>a.length<=this.rule;reduceJsonSchema(a){switch(a.type){case"string":return a.maxLength=this.rule,a;case"array":return a.maxItems=this.rule,a;default:return bc.throwInternalOperandError("maxLength",a)}}}let cm={implementation:ck,Node:cl},cn=ba({kind:"min",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:b0},normalize:a=>"number"==typeof a?{rule:a}:a,defaults:{description:a=>0===a.rule?a.exclusive?"positive":"non-negative":`${a.exclusive?"more than":"at least"} ${a.rule}`},intersections:{min:(a,b)=>a.isStricterThan(b)?a:b},obviatesBasisDescription:!0});class co extends bZ{impliedBasis=ap.intrinsic.number.internal;traverseAllows=this.exclusive?a=>a>this.rule:a=>a>=this.rule;reduceJsonSchema(a){return this.exclusive?a.exclusiveMinimum=this.rule:a.minimum=this.rule,a}}let cp={implementation:cn,Node:co},cq=ba({kind:"minLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:b4("minLength")}},reduce:a=>0===a.rule?ap.intrinsic.unknown:void 0,normalize:b1("minLength"),defaults:{description:a=>1===a.rule?"non-empty":`at least length ${a.rule}`,actual:a=>0===a.length?"":`${a.length}`},intersections:{minLength:(a,b)=>a.isStricterThan(b)?a:b}});class cr extends bZ{impliedBasis=ap.intrinsic.lengthBoundable.internal;traverseAllows=a=>a.length>=this.rule;reduceJsonSchema(a){switch(a.type){case"string":return a.minLength=this.rule,a;case"array":return a.minItems=this.rule,a;default:return bc.throwInternalOperandError("minLength",a)}}}let cs={implementation:cq,Node:cr},ct={min:cp.implementation,max:cj.implementation,minLength:cs.implementation,maxLength:cm.implementation,exactLength:cg.implementation,after:ca.implementation,before:cd.implementation},cu={min:cp.Node,max:cj.Node,minLength:cs.Node,maxLength:cm.Node,exactLength:cg.Node,after:ca.Node,before:cd.Node},cv=ba({kind:"pattern",collapsibleKey:"rule",keys:{rule:{},flags:{}},normalize:a=>"string"==typeof a?{rule:a}:a instanceof RegExp?a.flags?{rule:a.source,flags:a.flags}:{rule:a.source}:a,obviatesBasisDescription:!0,obviatesBasisExpression:!0,hasAssociatedError:!0,intersectionIsOpen:!0,defaults:{description:a=>`matched by ${a.rule}`},intersections:{pattern:()=>null}});class cw extends bJ{instance=new RegExp(this.rule,this.flags);expression=`${this.instance}`;traverseAllows=this.instance.test.bind(this.instance);compiledCondition=`${this.expression}.test(data)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=ap.intrinsic.string.internal;reduceJsonSchema(a,b){return a.pattern?b.fallback.patternIntersection({code:"patternIntersection",base:a,pattern:this.rule}):(a.pattern=this.rule,a)}}let cx={implementation:cv,Node:cw},cy=(a,b)=>{let c=cz(a);return b&&!b.includes(c)?u(`Root of kind ${c} should be one of ${b}`):c},cz=a=>{if(aV(a,"root"))return a.kind;if("string"==typeof a)return"$"===a[0]?"alias":a in o?"domain":"proto";if("function"==typeof a)return"proto";if("object"!=typeof a||null===a)return u(cA(a));if("morphs"in a)return"morph";if("branches"in a||L(a))return"union";if("unit"in a)return"unit";if("reference"in a)return"alias";let b=Object.keys(a);return 0===b.length||b.some(a=>a in a2)?"intersection":"proto"in a?"proto":"domain"in a?"domain":u(cA(a))},cA=a=>`${aw(a)} is not a valid type schema`,cB={},cC=a=>L(a)?a.map(a=>a.collapsibleJson):a.collapsibleJson,cD={};ap.nodesByRegisteredId=cD;let cE=a=>(cB[a]??=0,`${a}${++cB[a]}`),cF=a=>{let b=eh[a.kind],c=b.applyConfig?.(a.def,a.$.resolvedConfig)??a.def,d={},{meta:e,...f}=c,g=void 0===e?{}:"string"==typeof e?{description:e}:e;for(let c of w(f).sort(([a],[b])=>a5(a)?a5(b)?a6(a)-a6(b):1:a5(b)||a<b?-1:1).filter(([a,b])=>!a.startsWith("meta.")||(g[a.slice(5)]=b,!1))){let e=c[0],f=b.keys[e];if(!f)return u(`Key ${e} is not valid on ${a.kind} schema`);let g=f.parse?f.parse(c[1],a):c[1];g!==E&&(void 0!==g||f.preserveUndefined)&&(d[e]=g)}if(b.reduce&&!a.prereduced){let c=b.reduce(d,a.$);if(c)return c instanceof bw?c.throw():cH(c,g)}return cG({id:a.id,kind:a.kind,inner:d,meta:g,$:a.$})},cG=({id:a,kind:b,inner:c,meta:d,$:e,ignoreCache:f})=>{let g=eh[b],h=w(c),i=[],j={};for(let[a,b]of h){let c=g.keys[a],d=c.serialize??(c.child?cC:a8);j[a]=d(b),!0===c.child?L(b)?i.push(...b):i.push(b):"function"==typeof c.child&&i.push(...c.child(b))}g.finalizeInnerJson&&(j=g.finalizeInnerJson(j));let k={...j},l={};C(d)||(l=Q(d,(a,b)=>[a,"examples"===a?b:a8(b)]),k.meta=cI(l,"description",!0));let m=JSON.stringify({kind:b,...j=cI(j,g.collapsibleKey,!1)});k=cI(k,g.collapsibleKey,!1);let n=cI(k,g.collapsibleKey,!0),o=JSON.stringify({kind:b,...k});if(e.nodesByHash[o]&&!f)return e.nodesByHash[o];let p={id:a,kind:b,impl:g,inner:c,innerEntries:h,innerJson:j,innerHash:m,meta:d,metaJson:l,json:k,hash:o,collapsibleJson:n,children:i};if("intersection"!==b)for(let a in c)"in"!==a&&"out"!==a&&(p[a]=c[a]);let q=new ei[b](p,e);return e.nodesByHash[o]=q},cH=(a,b,c)=>(c&&aW(cD[c])&&r(`Unexpected attempt to overwrite node id ${c}`),cG({id:c??cE(b.alias??a.kind),kind:a.kind,inner:a.inner,meta:b,$:a.$})),cI=(a,b,c)=>{let d=Object.keys(a);if(1===d.length&&d[0]===b){let d=a[b];if(c||m(d,"object")&&(1===Object.keys(d).length||Array.isArray(d)))return d}return a},cJ=(a,b,c)=>{if(a.key!==b.key)return null;let d=a.key,e=bD(a.value,b.value,c),f=a.required||b.required?"required":"optional";if(e instanceof bw)if("optional"!==f)return e.withPrefixKey(a.key,a.required&&b.required?"required":"optional");else e=ap.intrinsic.never.internal;if("required"===f)return c.$.node("required",{key:d,value:e});let g=a.hasDefault()?b.hasDefault()?a.default===b.default?a.default:u(cL(a.default,b.default)):a.default:b.hasDefault()?b.default:E;return c.$.node("optional",{key:d,value:e,default:g})};class cK extends bI{required="required"===this.kind;optional="optional"===this.kind;impliedBasis=ap.intrinsic.object.internal;serializedKey=aO(this.key);compiledKey="string"==typeof this.key?this.key:this.serializedKey;flatRefs=i(this.value.flatRefs.map(a=>bs([this.key,...a.path],a.node)),bs([this.key],this.value));_transform(a,b){b.path.push(this.key);let c=super._transform(a,b);return b.path.pop(),c}hasDefault(){return"default"in this.inner}traverseAllows=(a,b)=>this.key in a?bm(this.key,()=>this.value.traverseAllows(a[this.key],b),b):this.optional;traverseApply=(a,b)=>{this.key in a?bm(this.key,()=>this.value.traverseApply(a[this.key],b),b):this.hasKind("required")&&b.errorFromNodeContext(this.errorContext)};compile(a){a.if(`${this.serializedKey} in data`,()=>a.traverseKey(this.serializedKey,`data${a.prop(this.key)}`,this.value)),this.hasKind("required")&&a.else(()=>"Apply"===a.traversalKind?a.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`):a.return(!1)),"Allows"===a.traversalKind&&a.return(!0)}}let cL=(a,b)=>`Invalid intersection of default values ${aw(a)} & ${aw(b)}`,cM=ba({kind:"optional",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(a,b)=>b.$.parseSchema(a)},default:{preserveUndefined:!0}},normalize:a=>a,reduce:(a,b)=>{if(!1===b.resolvedConfig.exactOptionalPropertyTypes&&!a.value.allows(void 0))return b.node("optional",{...a,value:a.value.or(eI.undefined)},{prereduced:!0})},defaults:{description:a=>`${a.compiledKey}?: ${a.value.description}`},intersections:{optional:cJ}});class cN extends cK{constructor(...a){super(...a),"default"in this.inner&&cS(this.value,this.inner.default,this.key)}get rawIn(){let a=super.rawIn;return this.hasDefault()?this.$.node("optional",B(a.inner,{default:!0}),{prereduced:!0}):a}get outProp(){if(!this.hasDefault())return this;let{default:a,...b}=this.inner;return this.cacheGetter("outProp",this.$.node("required",b,{prereduced:!0}))}expression=this.hasDefault()?`${this.compiledKey}: ${this.value.expression} = ${aw(this.inner.default)}`:`${this.compiledKey}?: ${this.value.expression}`;defaultValueMorph=cQ(this);defaultValueMorphRef=this.defaultValueMorph&&aM(this.defaultValueMorph)}let cO={implementation:cM,Node:cN},cP={},cQ=a=>{if(!a.hasDefault())return;let b=`{${a.compiledKey}: ${a.value.id} = ${a8(a.default)}}`;return cP[b]??=cR(a.key,a.value,a.default)},cR=(a,b,c)=>{if("function"==typeof c)return b.includesTransform?(d,e)=>(bm(a,()=>b(d[a]=c(),e),e),d):b=>(b[a]=c(),b);let d=b.includesTransform?b.assert(c):c;return m(d,"object")?(d,e)=>(bm(a,()=>b(d[a]=c,e),e),d):b=>(b[a]=d,b)},cS=(a,b,c)=>{let d=R(b);m(b,"object")&&!d&&u(cT(c));let e=a.in(d?b():b);if(e instanceof bi){null===c&&u(`Default ${e.summary}`);let a=e.transform(a=>a.transform(a=>({...a,prefixPath:[c]})));u(`Default for ${a.summary}`)}return b},cT=a=>{let b=null===a?"":"number"==typeof a?`for value at [${a}] `:`for ${aO(a)} `;return`Non-primitive default ${b}must be specified as a function like () => ({my: 'object'})`};class cU extends bn{constructor(a,b){super(a,b),Object.defineProperty(this,aU,{value:"root",enumerable:!1})}get rawIn(){return super.rawIn}get rawOut(){return super.rawOut}get internal(){return this}get"~standard"(){return{vendor:"arktype",version:1,validate:a=>{let b=this(a);return b instanceof bi?b:{value:b}},toJSONSchema:a=>a.target&&"draft-2020-12"!==a.target?u(`JSONSchema target '${a.target}' is not supported (must be "draft-2020-12")`):"input"===a.io?this.rawIn.toJsonSchema():this.rawOut.toJsonSchema()}}as(){return this}brand(a){return""===a?u(cV):this}readonly(){return this}branches=this.hasKind("union")?this.inner.branches:[this];distribute(a,b){let c=this.branches.map(a);return b?.(c)??c}get shortDescription(){return this.meta.description??this.defaultShortDescription}toJsonSchema(a={}){let b=be(this.$.resolvedConfig.toJsonSchema,a);b.useRefs||=this.isCyclic;let c="string"==typeof b.dialect?{$schema:b.dialect}:{};return Object.assign(c,this.toJsonSchemaRecurse(b)),b.useRefs&&(c.$defs=Q(this.references,(a,c)=>c.isRoot()&&!c.alwaysExpandJsonSchema?[c.id,c.toResolvedJsonSchema(b)]:[])),c}toJsonSchemaRecurse(a){return a.useRefs&&!this.alwaysExpandJsonSchema?{$ref:`#/$defs/${this.id}`}:this.toResolvedJsonSchema(a)}get alwaysExpandJsonSchema(){return this.isBasis()||"alias"===this.kind||this.hasKind("union")&&this.isBoolean}toResolvedJsonSchema(a){return Object.assign(this.innerToJsonSchema(a),this.metaJson)}intersect(a){let b=this.$.parseDefinition(a),c=this.rawIntersect(b);return c instanceof bw?c:this.$.finalize(c)}rawIntersect(a){return bB(this,a,this.$)}toNeverIfDisjoint(){return this}and(a){let b=this.intersect(a);return b instanceof bw?b.throw():b}rawAnd(a){let b=this.rawIntersect(a);return b instanceof bw?b.throw():b}or(a){let b=this.$.parseDefinition(a);return this.$.finalize(this.rawOr(b))}rawOr(a){let b=[...this.branches,...a.branches];return this.$.node("union",b)}map(a){return this.$.schema(this.applyStructuralOperation("map",[a]))}pick(...a){return this.$.schema(this.applyStructuralOperation("pick",a))}omit(...a){return this.$.schema(this.applyStructuralOperation("omit",a))}required(){return this.$.schema(this.applyStructuralOperation("required",[]))}partial(){return this.$.schema(this.applyStructuralOperation("partial",[]))}_keyof;keyof(){if(this._keyof)return this._keyof;let a=this.applyStructuralOperation("keyof",[]).reduce((a,b)=>a.intersect(b).toNeverIfDisjoint(),ap.intrinsic.unknown.internal);return 0===a.branches.length&&u(bz(`keyof ${this.expression}`)),this._keyof=this.$.finalize(a)}get props(){return 1!==this.branches.length?u(cZ(this.expression)):[...this.applyStructuralOperation("props",[])[0]]}merge(a){let b=this.$.parseDefinition(a);return this.$.schema(b.distribute(a=>this.applyStructuralOperation("merge",[cY(a)??u(c$("merge",a.expression))])))}applyStructuralOperation(a,b){return this.distribute(c=>{if(c.equals(ap.intrinsic.object)&&"merge"!==a)return c;let d=cY(c);if(d||u(c$(a,c.expression)),"keyof"===a)return d.keyof();if("get"===a)return d.get(...b);if("props"===a)return d.props;let e="required"===a?"require":"partial"===a?"optionalize":a;return this.$.node("intersection",{domain:"object",structure:d[e](...b)})})}get(...a){return void 0===a[0]?this:this.$.schema(this.applyStructuralOperation("get",a))}extract(a){let b=this.$.parseDefinition(a);return this.$.schema(this.branches.filter(a=>a.extends(b)))}exclude(a){let b=this.$.parseDefinition(a);return this.$.schema(this.branches.filter(a=>!a.extends(b)))}array(){return this.$.schema(this.isUnknown()?{proto:Array}:{proto:Array,sequence:this},{prereduced:!0})}overlaps(a){return!(this.intersect(a)instanceof bw)}extends(a){if(this.isNever())return!0;let b=this.intersect(a);return!(b instanceof bw)&&this.equals(b)}ifExtends(a){return this.extends(a)?this:void 0}subsumes(a){return this.$.parseDefinition(a).extends(this)}configure(a,b="shallow"){return this.configureReferences(a,b)}describe(a,b="shallow"){return this.configure({description:a},b)}optional(){return[this,"?"]}default(a){return cS(this,a,null),[this,"=",a]}from(a){return this.assert(a)}_pipe(...a){let b=a.reduce((a,b)=>a.rawPipeOnce(b),this);return this.$.finalize(b)}tryPipe(...a){let b=a.reduce((a,b)=>a.rawPipeOnce(aV(b,"root")?b:(a,c)=>{try{return b(a,c)}catch(a){return c.error({code:"predicate",predicate:b,actual:`aborted due to error:
    ${a}
`})}}),this);return this.$.finalize(b)}pipe=Object.assign(this._pipe.bind(this),{try:this.tryPipe.bind(this)});to(a){return this.$.finalize(this.toNode(this.$.parseDefinition(a)))}toNode(a){let b=bC(this,a,this.$);return b instanceof bw?b.throw():b}rawPipeOnce(a){return aV(a,"root")?this.toNode(a):this.distribute(b=>b.hasKind("morph")?this.$.node("morph",{in:b.inner.in,morphs:[...b.morphs,a]}):this.$.node("morph",{in:b,morphs:[a]}),this.$.parseSchema)}narrow(a){return this.constrainOut("predicate",a)}constrain(a,b){return this._constrain("root",a,b)}constrainIn(a,b){return this._constrain("in",a,b)}constrainOut(a,b){return this._constrain("out",a,b)}_constrain(a,b,c){let d=this.$.node(b,c);if(d.isRoot())return d.isUnknown()?this:r(`Unexpected constraint node ${d}`);let e="root"===a?this:"in"===a?this.rawIn:this.rawOut;if(e.hasKind("morph")||d.impliedBasis&&!e.extends(d.impliedBasis))return((...a)=>u(((a,b,c)=>{let d=c.hasKind("morph")?"a morph":c.isUnknown()?"unknown":c.exclude(b).defaultShortDescription;return`${(a=>a[0].toUpperCase()+a.slice(1))(a)} operand must be ${b.description} (was ${d})`})(...a)))(b,d.impliedBasis,this);let f=this.$.node("intersection",{[d.kind]:d}),g="out"===a?bC(this,f,this.$):bB(this,f,this.$);return g instanceof bw&&g.throw(),this.$.finalize(g)}onUndeclaredKey(a){let b="string"==typeof a?a:a.rule,c="string"!=typeof a&&a.deep;return this.$.finalize(this.transform((a,c)=>"structure"===a?"ignore"===b?B(c,{undeclared:1}):{...c,undeclared:b}:c,c?void 0:{shouldTransform:a=>!g(aY,a.kind)}))}hasEqualMorphs(a){return!this.includesTransform&&!a.includesTransform||!!l(this.shallowMorphs,a.shallowMorphs)&&!!l(this.flatMorphs,a.flatMorphs,{isEqual:(a,b)=>a.propString===b.propString&&(a.node.hasKind("morph")&&b.node.hasKind("morph")?a.node.hasEqualMorphs(b.node):!!(a.node.hasKind("intersection")&&b.node.hasKind("intersection"))&&a.node.structure?.structuralMorphRef===b.node.structure?.structuralMorphRef)})}onDeepUndeclaredKey(a){return this.onUndeclaredKey({rule:a,deep:!0})}filter(a){return this.constrainIn("predicate",a)}divisibleBy(a){return this.constrain("divisor",a)}matching(a){return this.constrain("pattern",a)}atLeast(a){return this.constrain("min",a)}atMost(a){return this.constrain("max",a)}moreThan(a){return this.constrain("min",cW(a))}lessThan(a){return this.constrain("max",cW(a))}atLeastLength(a){return this.constrain("minLength",a)}atMostLength(a){return this.constrain("maxLength",a)}moreThanLength(a){return this.constrain("minLength",cW(a))}lessThanLength(a){return this.constrain("maxLength",cW(a))}exactlyLength(a){return this.constrain("exactLength",a)}atOrAfter(a){return this.constrain("after",a)}atOrBefore(a){return this.constrain("before",a)}laterThan(a){return this.constrain("after",cW(a))}earlierThan(a){return this.constrain("before",cW(a))}}let cV="Expected a non-empty brand name after #",cW=a=>"object"!=typeof a||a instanceof Date?{rule:a,exclusive:!0}:{...a,exclusive:!0},cX=(a,b)=>aV(b,"root")?aV(a,"root")?a.extends(b):b.allows(a):aV(a,"root")?a.hasUnit(b):b===a,cY=a=>a.hasKind("morph")?null:a.hasKind("intersection")?a.inner.structure??(a.basis?.domain==="object"?a.$.bindReference(ap.intrinsic.emptyStructure):null):a.isBasis()&&"object"===a.domain?a.$.bindReference(ap.intrinsic.emptyStructure):null,cZ=a=>`Props cannot be extracted from a union. Use .distribute to extract props from each branch instead. Received:
${a}`,c$=(a,b)=>`${a} operand must be an object (was ${b})`,c_=(a,b)=>Q(a7(a),(a,c)=>[c,b]),c0=a=>a instanceof bw?ap.intrinsic.never.internal:a,c1=ba({kind:"alias",hasAssociatedError:!1,collapsibleKey:"reference",keys:{reference:{serialize:a=>a.startsWith("$")?a:`$ark.${a}`},resolve:{}},normalize:a=>"string"==typeof a?{reference:a}:a,defaults:{description:a=>a.reference},intersections:{alias:(a,b,c)=>c.$.lazilyResolve(()=>c0(bD(a.resolution,b.resolution,c)),`${a.reference}${c.pipe?"=>":"&"}${b.reference}`),...c_("alias",(a,b,c)=>b.isUnknown()?a:b.isNever()?b:b.isBasis()&&!b.overlaps(ap.intrinsic.object)?bw.init("assignability",ap.intrinsic.object,b):c.$.lazilyResolve(()=>c0(bD(a.resolution,b,c)),`${a.reference}${c.pipe?"=>":"&"}${b.id}`))}});class c2 extends cU{expression=this.reference;structure=void 0;get resolution(){let a=this._resolve();return cD[this.id]=a}_resolve(){if(this.resolve)return this.resolve();if("$"===this.reference[0])return this.$.resolveRoot(this.reference.slice(1));let a=cD[this.reference],b=[];for(;aV(a,"context");){if(b.includes(a.id))return u(c3(a.id,b));b.push(a.id),a=cD[a.id]}return aV(a,"root")?a:r(`Unexpected resolution for reference ${this.reference}
Seen: [${b.join("->")}] 
Resolution: ${aw(a)}`)}get resolutionId(){if(this.reference.includes("&")||this.reference.includes("=>"))return this.resolution.id;if("$"!==this.reference[0])return this.reference;let a=this.reference.slice(1),b=this.$.resolutions[a];return"string"==typeof b?b:aV(b,"root")?b.id:r(`Unexpected resolution for reference ${this.reference}: ${aw(b)}`)}get defaultShortDescription(){return o.object}innerToJsonSchema(a){return this.resolution.toJsonSchemaRecurse(a)}traverseAllows=(a,b)=>{let c=b.seen[this.reference];return!!c?.includes(a)||(b.seen[this.reference]=i(c,a),this.resolution.traverseAllows(a,b))};traverseApply=(a,b)=>{let c=b.seen[this.reference];c?.includes(a)||(b.seen[this.reference]=i(c,a),this.resolution.traverseApply(a,b))};compile(a){let b=this.resolutionId;a.if(`ctx.seen.${b} && ctx.seen.${b}.includes(data)`,()=>a.return(!0)),a.if(`!ctx.seen.${b}`,()=>a.line(`ctx.seen.${b} = []`)),a.line(`ctx.seen.${b}.push(data)`),a.return(a.invoke(b))}}let c3=(a,b)=>`Alias '${a}' has a shallow resolution cycle: ${[...b,a].join("->")}`,c4={implementation:c1,Node:c2};class c5 extends cU{traverseApply=(a,b)=>{this.traverseAllows(a,b)||b.errorFromNodeContext(this.errorContext)};get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return a9(this.errorContext)}compile(a){"Allows"===a.traversalKind?a.return(this.compiledCondition):a.if(this.compiledNegation,()=>a.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`))}}let c6=ba({kind:"domain",hasAssociatedError:!0,collapsibleKey:"domain",keys:{domain:{},numberAllowsNaN:{}},normalize:a=>"string"==typeof a?{domain:a}:"numberAllowsNaN"in a&&"number"!==a.domain?u(c8.writeBadAllowNanMessage(a.domain)):a,applyConfig:(a,b)=>void 0===a.numberAllowsNaN&&"number"===a.domain&&b.numberAllowsNaN?{...a,numberAllowsNaN:!0}:a,defaults:{description:a=>o[a.domain],actual:a=>Number.isNaN(a)?"NaN":o[n(a)]},intersections:{domain:(a,b)=>"number"===a.domain&&"number"===b.domain?a.numberAllowsNaN?b:a:bw.init("domain",a,b)}});class c7 extends c5{requiresNaNCheck="number"===this.domain&&!this.numberAllowsNaN;traverseAllows=this.requiresNaNCheck?a=>"number"==typeof a&&!Number.isNaN(a):a=>n(a)===this.domain;compiledCondition="object"===this.domain?'((typeof data === "object" && data !== null) || typeof data === "function")':`typeof data === "${this.domain}"${this.requiresNaNCheck?" && !Number.isNaN(data)":""}`;compiledNegation="object"===this.domain?'((typeof data !== "object" || data === null) && typeof data !== "function")':`typeof data !== "${this.domain}"${this.requiresNaNCheck?" || Number.isNaN(data)":""}`;expression=this.numberAllowsNaN?"number | NaN":this.domain;get nestableExpression(){return this.numberAllowsNaN?`(${this.expression})`:this.expression}get defaultShortDescription(){return o[this.domain]}innerToJsonSchema(a){return"bigint"===this.domain||"symbol"===this.domain?a.fallback.domain({code:"domain",base:{},domain:this.domain}):{type:this.domain}}}let c8={implementation:c6,Node:c7,writeBadAllowNanMessage:a=>`numberAllowsNaN may only be specified with domain "number" (was ${a})`},c9=ba({kind:"intersection",hasAssociatedError:!0,normalize:a=>{if(aW(a))return a;let{structure:b,...c}=a,d=!!b,e=b??{},f=Q(c,(a,b)=>x(a,a3)?(d&&u(`Flattened structure key ${a} cannot be specified alongside a root 'structure' key.`),e[a]=b,[]):[a,b]);return(aV(e,"constraint")||!C(e))&&(f.structure=e),f},finalizeInnerJson:({structure:a,...b})=>m(a,"object")?{...a,...b}:b,keys:{domain:{child:!0,parse:(a,b)=>b.$.node("domain",a)},proto:{child:!0,parse:(a,b)=>b.$.node("proto",a)},structure:{child:!0,parse:(a,b)=>b.$.node("structure",a),serialize:a=>{if(!a.sequence?.minLength)return a.collapsibleJson;let{sequence:b,...c}=a.collapsibleJson,{minVariadicLength:d,...e}=b,f=e.variadic&&1===Object.keys(e).length?e.variadic:e;return{...c,sequence:f}}},divisor:{child:!0,parse:bK("divisor")},max:{child:!0,parse:bK("max")},min:{child:!0,parse:bK("min")},maxLength:{child:!0,parse:bK("maxLength")},minLength:{child:!0,parse:bK("minLength")},exactLength:{child:!0,parse:bK("exactLength")},before:{child:!0,parse:bK("before")},after:{child:!0,parse:bK("after")},pattern:{child:!0,parse:bK("pattern")},predicate:{child:!0,parse:bK("predicate")}},reduce:(a,b)=>dd({},a,{$:b,invert:!1,pipe:!1}),defaults:{description:a=>{if(0===a.children.length)return"unknown";if(a.structure)return a.structure.description;let b=[];if(a.basis&&!a.prestructurals.some(a=>a.impl.obviatesBasisDescription)&&b.push(a.basis.description),a.prestructurals.length){let c=a.prestructurals.slice().sort((a,b)=>"min"===a.kind&&"max"===b.kind?-1:0).map(a=>a.description);b.push(...c)}return a.inner.predicate&&b.push(...a.inner.predicate.map(a=>a.description)),b.join(" and ")},expected:a=>`  ◦ ${a.errors.map(a=>a.expected).join("\n  ◦ ")}`,problem:a=>`(${a.actual}) must be...
${a.expected}`},intersections:{intersection:(a,b,c)=>dd(a.inner,b.inner,c),...c_("intersection",(a,b,c)=>{if(0===a.children.length)return b;let{domain:d,proto:e,...f}=a.inner,g=e??d,h=g?bD(g,b,c):b;return h instanceof bw?h:a?.basis?.equals(h)?a:a.$.node("intersection",{...f,[h.kind]:h},{prereduced:!0})})}});class da extends cU{basis=this.inner.domain??this.inner.proto??null;prestructurals=[];refinements=this.children.filter(a=>!!a.isRefinement()&&(g(aZ,a.kind)&&this.prestructurals.push(a),!0));structure=this.inner.structure;expression=dc(this);get shallowMorphs(){return this.inner.structure?.structuralMorph?[this.inner.structure.structuralMorph]:[]}get defaultShortDescription(){return this.basis?.defaultShortDescription??"present"}innerToJsonSchema(a){return this.children.reduce((b,c)=>c.isBasis()?c.toJsonSchemaRecurse(a):c.reduceJsonSchema(b,a),{})}traverseAllows=(a,b)=>this.children.every(c=>c.traverseAllows(a,b));traverseApply=(a,b)=>{let c=b.currentErrorCount;if(!this.basis||(this.basis.traverseApply(a,b),!(b.currentErrorCount>c))){if(this.prestructurals.length){for(let d=0;d<this.prestructurals.length-1;d++)if(this.prestructurals[d].traverseApply(a,b),b.failFast&&b.currentErrorCount>c)return;if(this.prestructurals[this.prestructurals.length-1].traverseApply(a,b),b.currentErrorCount>c)return}if((!this.structure||(this.structure.traverseApply(a,b),!(b.currentErrorCount>c)))&&this.inner.predicate){for(let d=0;d<this.inner.predicate.length-1;d++)if(this.inner.predicate[d].traverseApply(a,b),b.failFast&&b.currentErrorCount>c)return;this.inner.predicate[this.inner.predicate.length-1].traverseApply(a,b)}}};compile(a){if("Allows"===a.traversalKind){for(let b of this.children)a.check(b);a.return(!0);return}if(a.initializeErrorCount(),this.basis&&(a.check(this.basis),this.children.length>1&&a.returnIfFail()),this.prestructurals.length){for(let b=0;b<this.prestructurals.length-1;b++)a.check(this.prestructurals[b]),a.returnIfFailFast();a.check(this.prestructurals[this.prestructurals.length-1]),(this.structure||this.inner.predicate)&&a.returnIfFail()}if(this.structure&&(a.check(this.structure),this.inner.predicate&&a.returnIfFail()),this.inner.predicate){for(let b=0;b<this.inner.predicate.length-1;b++)a.check(this.inner.predicate[b]),a.returnIfFail();a.check(this.inner.predicate[this.inner.predicate.length-1])}}}let db={implementation:c9,Node:da},dc=a=>{if(a.structure?.expression)return a.structure.expression;let b=a.basis&&!a.prestructurals.some(a=>a.impl.obviatesBasisExpression)?a.basis.nestableExpression:"",c=a.prestructurals.map(a=>a.expression).join(" & "),d=`${b}${b?" ":""}${c}`;return"Array == 0"===d?"[]":d||"unknown"},dd=(a,b,c)=>{let d={},e=a.proto??a.domain,f=b.proto??b.domain,g=e?f?bD(e,f,c):e:f;return g instanceof bw?g:(g&&(d[g.kind]=g),bL({kind:"intersection",baseInner:d,l:bM(a),r:bM(b),roots:[],ctx:c}))},de=ba({kind:"morph",hasAssociatedError:!1,keys:{in:{child:!0,parse:(a,b)=>b.$.parseSchema(a)},morphs:{parse:e,serialize:a=>a.map(a=>aV(a,"root")?a.json:aM(a))},declaredIn:{child:!1,serialize:a=>a.json},declaredOut:{child:!1,serialize:a=>a.json}},normalize:a=>a,defaults:{description:a=>`a morph from ${a.rawIn.description} to ${a.rawOut?.description??"unknown"}`},intersections:{morph:(a,b,c)=>{if(!a.hasEqualMorphs(b))return u(dh(a.expression,b.expression));let d=bD(a.rawIn,b.rawIn,c);if(d instanceof bw)return d;let e={morphs:a.morphs};if(a.declaredIn||b.declaredIn){let d=bD(a.rawIn,b.rawIn,c);if(d instanceof bw)return d.throw();e.declaredIn=d}if(a.declaredOut||b.declaredOut){let d=bD(a.rawOut,b.rawOut,c);if(d instanceof bw)return d.throw();e.declaredOut=d}return d.distribute(a=>c.$.node("morph",{...e,in:a}),c.$.parseSchema)},...c_("morph",(a,b,c)=>{let d=a.inner.in?bD(a.inner.in,b,c):b;return d instanceof bw?d:d.equals(a.inner.in)?a:c.$.node("morph",{...a.inner,in:d})})}});class df extends cU{serializedMorphs=this.morphs.map(aM);compiledMorphs=`[${this.serializedMorphs}]`;lastMorph=this.inner.morphs[this.inner.morphs.length-1];lastMorphIfNode=aV(this.lastMorph,"root")?this.lastMorph:void 0;introspectableIn=this.inner.in;introspectableOut=this.lastMorphIfNode?Object.assign(this.referencesById,this.lastMorphIfNode.referencesById)&&this.lastMorphIfNode.rawOut:void 0;get shallowMorphs(){return Array.isArray(this.inner.in?.shallowMorphs)?[...this.inner.in.shallowMorphs,...this.morphs]:this.morphs}get rawIn(){return this.declaredIn??this.inner.in?.rawIn??ap.intrinsic.unknown.internal}get rawOut(){return this.declaredOut??this.introspectableOut??ap.intrinsic.unknown.internal}declareIn(a){return this.$.node("morph",{...this.inner,declaredIn:a})}declareOut(a){return this.$.node("morph",{...this.inner,declaredOut:a})}expression=`(In: ${this.rawIn.expression}) => ${this.lastMorphIfNode?"To":"Out"}<${this.rawOut.expression}>`;get defaultShortDescription(){return this.rawIn.meta.description??this.rawIn.defaultShortDescription}innerToJsonSchema(a){return a.fallback.morph({code:"morph",base:this.rawIn.toJsonSchemaRecurse(a),out:this.introspectableOut?.toJsonSchemaRecurse(a)??null})}compile(a){if("Allows"===a.traversalKind){if(!this.introspectableIn)return;a.return(a.invoke(this.introspectableIn));return}this.introspectableIn&&a.line(a.invoke(this.introspectableIn)),a.line(`ctx.queueMorphs(${this.compiledMorphs})`)}traverseAllows=(a,b)=>!this.introspectableIn||this.introspectableIn.traverseAllows(a,b);traverseApply=(a,b)=>{this.introspectableIn&&this.introspectableIn.traverseApply(a,b),b.queueMorphs(this.morphs)};hasEqualMorphs(a){return l(this.morphs,a.morphs,{isEqual:(a,b)=>a===b||aV(a,"root")&&aV(b,"root")&&a.equals(b)})}}let dg={implementation:de,Node:df},dh=(a,b)=>`The intersection of distinct morphs at a single path is indeterminate:
Left: ${a}
Right: ${b}`,di=ba({kind:"proto",hasAssociatedError:!0,collapsibleKey:"proto",keys:{proto:{serialize:a=>N(a)??a8(a)},dateAllowsInvalid:{}},normalize:a=>{let b="string"==typeof a?{proto:I[a]}:"function"==typeof a?aW(a)?a:{proto:a}:"string"==typeof a.proto?{...a,proto:I[a.proto]}:a;return"function"!=typeof b.proto&&u(dk.writeInvalidSchemaMessage(b.proto)),"dateAllowsInvalid"in b&&b.proto!==Date&&u(dk.writeBadInvalidDateMessage(b.proto)),b},applyConfig:(a,b)=>void 0===a.dateAllowsInvalid&&a.proto===Date&&b.dateAllowsInvalid?{...a,dateAllowsInvalid:!0}:a,defaults:{description:a=>a.builtinName?M[a.builtinName]:`an instance of ${a.proto.name}`,actual:a=>a instanceof Date&&"Invalid Date"===a.toString()?"an invalid Date":K(a)},intersections:{proto:(a,b)=>a.proto===Date&&b.proto===Date?a.dateAllowsInvalid?b:a:O(a.proto,b.proto)?a:O(b.proto,a.proto)?b:bw.init("proto",a,b),domain:(a,b)=>"object"===b.domain?a:bw.init("domain",ap.intrinsic.object.internal,b)}});class dj extends c5{builtinName=N(this.proto);serializedConstructor=this.json.proto;requiresInvalidDateCheck=this.proto===Date&&!this.dateAllowsInvalid;traverseAllows=this.requiresInvalidDateCheck?a=>a instanceof Date&&"Invalid Date"!==a.toString():a=>a instanceof this.proto;compiledCondition=`data instanceof ${this.serializedConstructor}${this.requiresInvalidDateCheck?' && data.toString() !== "Invalid Date"':""}`;compiledNegation=`!(${this.compiledCondition})`;innerToJsonSchema(a){switch(this.builtinName){case"Array":return{type:"array"};case"Date":return a.fallback.date?.({code:"date",base:{}})??a.fallback.proto({code:"proto",base:{},proto:this.proto});default:return a.fallback.proto({code:"proto",base:{},proto:this.proto})}}expression=this.dateAllowsInvalid?"Date | InvalidDate":this.proto.name;get nestableExpression(){return this.dateAllowsInvalid?`(${this.expression})`:this.expression}domain="object";get defaultShortDescription(){return this.description}}let dk={implementation:di,Node:dj,writeBadInvalidDateMessage:a=>`dateAllowsInvalid may only be specified with constructor Date (was ${a.name})`,writeInvalidSchemaMessage:a=>`instanceOf operand must be a function (was ${n(a)})`},dl=ba({kind:"union",hasAssociatedError:!0,collapsibleKey:"branches",keys:{ordered:{},branches:{child:!0,parse:(a,b)=>{let c=[];for(let d of a)for(let a of aV(d,"root")?d.branches:b.$.parseSchema(d).branches)if(a.hasKind("morph")){let d=c.findIndex(b=>b.hasKind("morph")&&b.hasEqualMorphs(a));if(-1===d)c.push(a);else{let e=c[d];c[d]=b.$.node("morph",{...e.inner,in:e.rawIn.rawOr(a.rawIn)})}}else c.push(a);return b.def.ordered||c.sort((a,b)=>a.hash<b.hash?-1:1),c}}},normalize:a=>L(a)?{branches:a}:a,reduce:(a,b)=>{let c=dB(a);return 1===c.length?c[0]:c.length!==a.branches.length?b.node("union",{...a,branches:c},{prereduced:!0}):void 0},defaults:{description:a=>a.distribute(a=>a.description,dz),expected:a=>{let b=Object.entries(a.errors.reduce((a,b)=>{let c=b.propString;return a[c]=i(a[c],b),a},{})).map(([a,b])=>{let c=[];for(let a of b)k(c,a.expected);let d=dz(c),e=b.every(a=>a.actual===b[0].actual)?b[0].actual:aw(b[0].data);return`${a&&`${a} `}must be ${d}${e&&` (was ${e})`}`});return dz(b)},problem:a=>a.expected,message:a=>"["===a.problem[0]?`value at ${a.problem}`:a.problem},intersections:{union:(a,b,c)=>{let d;return a.isNever!==b.isNever?bw.init("presence",a,b):(a.ordered?(b.ordered&&u(dF(a.expression,b.expression)),(d=dA(b.branches,a.branches,c))instanceof bw&&d.invert()):d=dA(a.branches,b.branches,c),d instanceof bw)?d:c.$.parseSchema(a.ordered||b.ordered?{branches:d,ordered:!0}:{branches:d})},...c_("union",(a,b,c)=>{let d=dA(a.branches,[b],c);return d instanceof bw?d:1===d.length?d[0]:c.$.parseSchema(a.ordered?{branches:d,ordered:!0}:{branches:d})})}});class dm extends cU{isBoolean=2===this.branches.length&&this.branches[0].hasUnit(!1)&&this.branches[1].hasUnit(!0);get branchGroups(){let a=[],b=-1;for(let c of this.branches){if(c.hasKind("unit")&&"boolean"===c.domain){-1===b?(b=a.length,a.push(c)):a[b]=ap.intrinsic.boolean;continue}a.push(c)}return a}unitBranches=this.branches.filter(a=>a.rawIn.hasKind("unit"));discriminant=this.discriminate();discriminantJson=this.discriminant?dw(this.discriminant):null;expression=this.distribute(a=>a.nestableExpression,dy);createBranchedOptimisticRootApply(){return(a,b)=>{let c=this.traverseOptimistic(a);if(c!==E)return c;let d=new bl(a,this.$.resolvedConfig);return this.traverseApply(a,d),d.finalize(b)}}get shallowMorphs(){return this.branches.reduce((a,b)=>k(a,b.shallowMorphs),[])}get defaultShortDescription(){return this.distribute(a=>a.defaultShortDescription,dz)}innerToJsonSchema(a){if(1===this.branchGroups.length&&this.branchGroups[0].equals(ap.intrinsic.boolean))return{type:"boolean"};let b=this.branchGroups.map(b=>b.toJsonSchemaRecurse(a));return b.every(a=>1===Object.keys(a).length&&"const"in a)?{enum:b.map(a=>a.const)}:{anyOf:b}}traverseAllows=(a,b)=>this.branches.some(c=>c.traverseAllows(a,b));traverseApply=(a,b)=>{let c=[];for(let d=0;d<this.branches.length;d++){if(b.pushBranch(),this.branches[d].traverseApply(a,b),!b.hasError()){if(this.branches[d].includesTransform)return b.queuedMorphs.push(...b.popBranch().queuedMorphs);return b.popBranch()}c.push(b.popBranch().error)}b.errorFromNodeContext({code:"union",errors:c,meta:this.meta})};traverseOptimistic=a=>{for(let b=0;b<this.branches.length;b++){let c=this.branches[b];if(c.traverseAllows(a)){if(c.contextFreeMorph)return c.contextFreeMorph(a);return a}}return E};compile(a){if(!this.discriminant||this.unitBranches.length===this.branches.length&&2===this.branches.length)return this.compileIndiscriminable(a);let b=this.discriminant.optionallyChainedPropString;"domain"===this.discriminant.kind&&(b=`typeof ${b} === "object" ? ${b} === null ? "null" : "object" : typeof ${b} === "function" ? "object" : typeof ${b}`);let c=this.discriminant.cases,d=Object.keys(c),{optimistic:e}=a;if(a.optimistic=!1,a.block(`switch(${b})`,()=>{for(let b in c){let d,f=c[b],g="default"===b?b:`case ${b}`;d=!0===f?e?"data":"true":e?"branchedOptimistic"===f.rootApplyStrategy?a.invoke(f,{kind:"Optimistic"}):f.contextFreeMorph?`${a.invoke(f)} ? ${aM(f.contextFreeMorph)}(data) : "${E}"`:`${a.invoke(f)} ? data : "${E}"`:a.invoke(f),a.line(`${g}: return ${d}`)}return a}),"Allows"===a.traversalKind)return void a.return(!!e&&`"${E}"`);let f=dz("domain"===this.discriminant.kind?d.map(a=>{let b=a.slice(1,-1);return"function"===b?o.object:o[b]}):d),g=this.discriminant.path.map(a=>"symbol"==typeof a?aM(a):JSON.stringify(a)),h=JSON.stringify(f),i="domain"===this.discriminant.kind?`${dt}[${b}]`:`${du}(${b})`;a.line(`ctx.errorFromNodeContext({
	code: "predicate",
	expected: ${h},
	actual: ${i},
	relativePath: [${g}],
	meta: ${this.compiledMeta}
})`)}compileIndiscriminable(a){if("Apply"===a.traversalKind){for(let b of(a.const("errors","[]"),this.branches))a.line("ctx.pushBranch()").line(a.invoke(b)).if("!ctx.hasError()",()=>a.return(b.includesTransform?"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)":"ctx.popBranch()")).line("errors.push(ctx.popBranch().error)");a.line(`ctx.errorFromNodeContext({ code: "union", errors, meta: ${this.compiledMeta} })`)}else{let{optimistic:b}=a;for(let c of(a.optimistic=!1,this.branches))a.if(`${a.invoke(c)}`,()=>a.return(!b||(c.contextFreeMorph?`${aM(c.contextFreeMorph)}(data)`:"data")));a.return(!!b&&`"${E}"`)}}get nestableExpression(){return this.isBoolean?"boolean":`(${this.expression})`}discriminate(){if(this.branches.length<2||this.isCyclic)return null;if(this.unitBranches.length===this.branches.length)return{kind:"unit",path:[],optionallyChainedPropString:"data",cases:Q(this.unitBranches,(a,b)=>[`${b.rawIn.serializedValue}`,!b.hasKind("morph")||b])};let a=[];for(let b=0;b<this.branches.length-1;b++){let c=this.branches[b];for(let d=b+1;d<this.branches.length;d++){let e=this.branches[d],f=bB(c.rawIn,e.rawIn,c.$);if(f instanceof bw)for(let c of f){let e,f;if(!c.kind||c.optional)continue;if("domain"===c.kind){let a=c.l,b=c.r;e=`"${"string"==typeof a?a:a.domain}"`,f=`"${"string"==typeof b?b:b.domain}"`}else{if("unit"!==c.kind)continue;e=c.l.serializedValue,f=c.r.serializedValue}let g=a.find(a=>l(a.path,c.path)&&a.kind===c.kind);g?(g.cases[e]?g.cases[e].branchIndices=k(g.cases[e].branchIndices,b):g.cases[e]??={branchIndices:[b],condition:c.l},g.cases[f]?g.cases[f].branchIndices=k(g.cases[f].branchIndices,d):g.cases[f]??={branchIndices:[d],condition:c.r}):a.push({kind:c.kind,cases:{[e]:{branchIndices:[b],condition:c.l},[f]:{branchIndices:[d],condition:c.r}},path:c.path})}}}let b=this.ordered?dq(a,this.branches):a;if(!b.length)return null;let c=dn(b,this),d={};for(let a in c.best.cases){let b=dp(c,a);if(null===b){d[a]=!0;continue}if(b.length===this.branches.length)return null;this.ordered&&b.sort((a,b)=>a.originalIndex-b.originalIndex);let e=b.map(a=>a.branch),f=1===e.length?e[0]:this.$.node("union",this.ordered?{branches:e,ordered:!0}:e);Object.assign(this.referencesById,f.referencesById),d[a]=f}if(c.defaultEntries.length){let a=c.defaultEntries.map(a=>a.branch);d.default=this.$.node("union",this.ordered?{branches:a,ordered:!0}:a,{prereduced:!0}),Object.assign(this.referencesById,d.default.referencesById)}return Object.assign(c.location,{cases:d})}}let dn=(a,b)=>{let c=a.sort((a,b)=>a.path.length===b.path.length?Object.keys(b.cases).length-Object.keys(a.cases).length:a.path.length-b.path.length)[0],d={kind:c.kind,path:c.path,optionallyChainedPropString:ds(c.path)};return{best:c,location:d,defaultEntries:b.branches.map((a,b)=>({originalIndex:b,branch:a})),node:b}},dp=(a,b)=>{let c=a.best.cases[b],d=dr(c.condition,a.location.path,a.node.$),e=[],f=[];for(let b=0;b<a.defaultEntries.length;b++){let g=a.defaultEntries[b];if(c.branchIndices.includes(g.originalIndex)){let b=dD(a.node.branches[g.originalIndex],a.location);null===b?e=null:e?.push({originalIndex:g.originalIndex,branch:b})}else if(g.branch.hasKind("alias")&&d.hasKind("domain")&&"object"===d.domain)e?.push(g);else{if(g.branch.rawIn.overlaps(d)){let b=dD(g.branch,a.location);e?.push({originalIndex:g.originalIndex,branch:b})}f.push(g)}}return a.defaultEntries=f,e},dq=(a,b)=>a.filter(a=>{let c=Object.values(a.cases).map(a=>a.branchIndices);for(let a=0;a<c.length-1;a++){let d=c[a];for(let e=a+1;e<c.length;e++){let a=c[e];for(let c of d)for(let d of a)if(c>d&&b[c].overlaps(b[d]))return!1}}return!0}),dr=(a,b,c)=>{let d="undefined"===a?c.node("unit",{unit:void 0}):"null"===a?c.node("unit",{unit:null}):"boolean"===a?c.units([!0,!1]):a;for(let a=b.length-1;a>=0;a--){let e=b[a];d=c.node("intersection","number"==typeof e?{proto:"Array",sequence:[...h(e).map(a=>({})),d]}:{domain:"object",required:[{key:e,value:d}]})}return d},ds=a=>a.reduce((a,b)=>a+aP(b,!0),"data"),dt=aM(p),du=aM(aw),dv={implementation:dl,Node:dm},dw=a=>({kind:a.kind,path:a.path.map(a=>"string"==typeof a?a:aO(a)),cases:Q(a.cases,(a,b)=>[a,!0===b?b:b.hasKind("union")&&b.discriminantJson?b.discriminantJson:b.json])}),dx={delimiter:" | ",finalDelimiter:" | "},dy=a=>dz(a,dx),dz=(a,b)=>{let c=b?.delimiter??", ",d=b?.finalDelimiter??" or ";if(0===a.length)return"never";if(1===a.length)return a[0];if(2===a.length&&"false"===a[0]&&"true"===a[1]||"true"===a[0]&&"false"===a[1])return"boolean";let e={},f=a.filter(a=>!e[a]&&(e[a]=!0)),g=f.pop();return`${f.join(c)}${f.length?d:""}${g}`},dA=(a,b,c)=>{let d=b.map(()=>[]);for(let e=0;e<a.length;e++){let f={};for(let g=0;g<b.length;g++){if(null===d[g])continue;if(a[e].equals(b[g])){d[g]=null,f={};break}let h=bD(a[e],b[g],c);if(!(h instanceof bw)){if(h.equals(a[e])){d[g].push(a[e]),f={};break}h.equals(b[g])?d[g]=null:f[g]=h}}for(let a in f)d[a][e]=f[a]}let e=d.flatMap((a,c)=>a?.flatMap(a=>a.branches)??b[c]);return 0===e.length?bw.init("union",a,b):e},dB=({branches:a,ordered:b})=>{if(a.length<2)return a;let c=a.map(()=>!0);for(let d=0;d<a.length;d++)for(let e=d+1;e<a.length&&c[d]&&c[e];e++){if(a[d].equals(a[e])){c[e]=!1;continue}let f=bB(a[d].rawIn,a[e].rawIn,a[0].$);f instanceof bw||(b||dC(a[d],a[e]),f.equals(a[d].rawIn)?c[d]=!!b:f.equals(a[e].rawIn)&&(c[e]=!1))}return a.filter((a,b)=>c[b])},dC=(a,b)=>{(a.includesTransform||b.includesTransform)&&(l(a.shallowMorphs,b.shallowMorphs)||u(dE(a.expression,b.expression)),l(a.flatMorphs,b.flatMorphs,{isEqual:(a,b)=>a.propString===b.propString&&(a.node.hasKind("morph")&&b.node.hasKind("morph")?a.node.hasEqualMorphs(b.node):!!(a.node.hasKind("intersection")&&b.node.hasKind("intersection"))&&a.node.structure?.structuralMorphRef===b.node.structure?.structuralMorphRef)})||u(dE(a.expression,b.expression)))},dD=(a,b)=>a.transform((a,b)=>"domain"===a||"unit"===a?null:b,{shouldTransform:(a,c)=>{let d=ds(c.path);return!!b.optionallyChainedPropString.startsWith(d)&&(!!(a.hasKind("domain")&&"object"===a.domain||(a.hasKind("domain")||"unit"===b.kind)&&d===b.optionallyChainedPropString)||0!==a.children.length&&"index"!==a.kind)}}),dE=(a,b)=>`An unordered union of a type including a morph and a type with overlapping input is indeterminate:
Left: ${a}
Right: ${b}`,dF=(a,b)=>`The intersection of two ordered unions is indeterminate:
Left: ${a}
Right: ${b}`,dG=ba({kind:"unit",hasAssociatedError:!0,keys:{unit:{preserveUndefined:!0,serialize:a=>a instanceof Date?a.toISOString():a8(a)}},normalize:a=>a,defaults:{description:a=>aw(a.unit),problem:({expected:a,actual:b})=>`${a===b?`must be reference equal to ${a} (serialized to the same value)`:`must be ${a} (was ${b})`}`},intersections:{unit:(a,b)=>bw.init("unit",a,b),...c_("unit",(a,b)=>{if(b.allows(a.unit))return a;let c=b.hasKind("intersection")?b.basis:b;if(c){let b=c.hasKind("domain")?c:ap.intrinsic.object;if(a.domain!==b.domain){let c="undefined"===a.domain||"null"===a.domain||"boolean"===a.domain?a.domain:ap.intrinsic[a.domain];return bw.init("domain",c,b)}}return bw.init("assignability",a,b.hasKind("intersection")?b.children.find(b=>!b.allows(a.unit)):b)})}});class dH extends c5{compiledValue=this.json.unit;serializedValue="string"==typeof this.unit||this.unit instanceof Date?JSON.stringify(this.compiledValue):`${this.compiledValue}`;compiledCondition=dJ(this.unit,this.serializedValue);compiledNegation=dJ(this.unit,this.serializedValue,"negated");expression=aw(this.unit);domain=n(this.unit);get defaultShortDescription(){return"object"===this.domain?o.object:this.description}innerToJsonSchema(a){return null===this.unit?{type:"null"}:ap.intrinsic.jsonPrimitive.allows(this.unit)?{const:this.unit}:a.fallback.unit({code:"unit",base:{},unit:this.unit})}traverseAllows=this.unit instanceof Date?a=>a instanceof Date&&a.toISOString()===this.compiledValue:Number.isNaN(this.unit)?a=>Number.isNaN(a):a=>a===this.unit}let dI={implementation:dG,Node:dH},dJ=(a,b,c)=>{if(a instanceof Date){let a=`data instanceof Date && data.toISOString() === ${b}`;return c?`!(${a})`:a}return Number.isNaN(a)?`${c?"!":""}Number.isNaN(data)`:`data ${c?"!":"="}== ${b}`},dK=ba({kind:"index",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{signature:{child:!0,parse:(a,b)=>{let c=b.$.parseSchema(a);if(!c.extends(ap.intrinsic.key))return u(dO(c.expression));let d=c.branches.filter(a=>a.hasKind("unit"));return d.length?u(dN(d.map(a=>aw(a.unit)))):c}},value:{child:!0,parse:(a,b)=>b.$.parseSchema(a)}},normalize:a=>a,defaults:{description:a=>`[${a.signature.expression}]: ${a.value.description}`},intersections:{index:(a,b,c)=>{if(a.signature.equals(b.signature)){let d=bD(a.value,b.value,c),e=d instanceof bw?ap.intrinsic.never.internal:d;return c.$.node("index",{signature:a.signature,value:e})}return a.signature.extends(b.signature)&&a.value.subsumes(b.value)?b:b.signature.extends(a.signature)&&b.value.subsumes(a.value)?a:null}}});class dL extends bI{impliedBasis=ap.intrinsic.object.internal;expression=`[${this.signature.expression}]: ${this.value.expression}`;flatRefs=i(this.value.flatRefs.map(a=>bs([this.signature,...a.path],a.node)),bs([this.signature],this.value));traverseAllows=(a,b)=>D(a).every(a=>!this.signature.traverseAllows(a[0],b)||bm(a[0],()=>this.value.traverseAllows(a[1],b),b));traverseApply=(a,b)=>{for(let c of D(a))this.signature.traverseAllows(c[0],b)&&bm(c[0],()=>this.value.traverseApply(c[1],b),b)};_transform(a,b){b.path.push(this.signature);let c=super._transform(a,b);return b.path.pop(),c}compile(){}}let dM={implementation:dK,Node:dL},dN=a=>`Index keys ${a.join(", ")} should be specified as named props.`,dO=a=>`Indexed key definition '${a}' must be a string or symbol`,dP=ba({kind:"required",hasAssociatedError:!0,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(a,b)=>b.$.parseSchema(a)}},normalize:a=>a,defaults:{description:a=>`${a.compiledKey}: ${a.value.description}`,expected:a=>a.missingValueDescription,actual:()=>"missing"},intersections:{required:cJ,optional:cJ}});class dQ extends cK{expression=`${this.compiledKey}: ${this.value.expression}`;errorContext=Object.freeze({code:"required",missingValueDescription:this.value.defaultShortDescription,relativePath:[this.key],meta:this.meta});compiledErrorContext=a9(this.errorContext)}let dR={implementation:dP,Node:dQ},dS=ba({kind:"sequence",hasAssociatedError:!1,collapsibleKey:"variadic",keys:{prefix:{child:!0,parse:(a,b)=>{if(0!==a.length)return a.map(a=>b.$.parseSchema(a))}},optionals:{child:!0,parse:(a,b)=>{if(0!==a.length)return a.map(a=>b.$.parseSchema(a))}},defaultables:{child:a=>a.map(a=>a[0]),parse:(a,b)=>{if(0!==a.length)return a.map(a=>{let c=b.$.parseSchema(a[0]);return cS(c,a[1],null),[c,a[1]]})},serialize:a=>a.map(a=>[a[0].collapsibleJson,a8(a[1])]),reduceIo:(a,b,c)=>{if("in"===a){b.optionals=c.map(a=>a[0].rawIn);return}b.prefix=c.map(a=>a[0].rawOut)}},variadic:{child:!0,parse:(a,b)=>b.$.parseSchema(a,b)},minVariadicLength:{parse:a=>0===a?void 0:a},postfix:{child:!0,parse:(a,b)=>{if(0!==a.length)return a.map(a=>b.$.parseSchema(a))}}},normalize:a=>{if("string"==typeof a)return{variadic:a};if("variadic"in a||"prefix"in a||"defaultables"in a||"optionals"in a||"postfix"in a||"minVariadicLength"in a){if(a.postfix?.length){if(!a.variadic)return u(d$);if(a.optionals?.length||a.defaultables?.length)return u(dZ)}return a.minVariadicLength&&!a.variadic?u("minVariadicLength may not be specified without a variadic element"):a}return{variadic:a}},reduce:(a,b)=>{let c=a.minVariadicLength??0,d=a.prefix?.slice()??[],e=a.defaultables?.slice()??[],f=a.optionals?.slice()??[],g=a.postfix?.slice()??[];if(a.variadic){for(;f[f.length-1]?.equals(a.variadic);)f.pop();if(0===f.length&&0===e.length)for(;d[d.length-1]?.equals(a.variadic);)d.pop(),c++;for(;g[0]?.equals(a.variadic);)g.shift(),c++}else 0===f.length&&0===e.length&&d.push(...g.splice(0));if(c!==a.minVariadicLength||a.prefix&&a.prefix.length!==d.length)return b.node("sequence",{...a,prefix:d,defaultables:e,optionals:f,postfix:g,minVariadicLength:c},{prereduced:!0})},defaults:{description:a=>{if(a.isVariadicOnly)return`${a.variadic.nestableExpression}[]`;let b=a.tuple.map(a=>"defaultables"===a.kind?`${a.node.nestableExpression} = ${aw(a.default)}`:"optionals"===a.kind?`${a.node.nestableExpression}?`:"variadic"===a.kind?`...${a.node.nestableExpression}[]`:a.node.expression).join(", ");return`[${b}]`}},intersections:{sequence:(a,b,c)=>{let d=d_({l:a.tuple,r:b.tuple,disjoint:new bw,result:[],fixedVariants:[],ctx:c}),e=0===d.disjoint.length?[d,...d.fixedVariants]:d.fixedVariants;return 0===e.length?d.disjoint:1===e.length?c.$.node("sequence",dY(e[0].result)):c.$.node("union",e.map(a=>({proto:Array,sequence:dY(a.result)})))}}});class dT extends bI{impliedBasis=ap.intrinsic.Array.internal;tuple=dX(this.inner);prefixLength=this.prefix?.length??0;defaultablesLength=this.defaultables?.length??0;optionalsLength=this.optionals?.length??0;postfixLength=this.postfix?.length??0;defaultablesAndOptionals=[];prevariadic=this.tuple.filter(a=>"defaultables"===a.kind||"optionals"===a.kind?(this.defaultablesAndOptionals.push(a.node),!0):"prefix"===a.kind);variadicOrPostfix=j(this.variadic&&[this.variadic],this.postfix);flatRefs=this.addFlatRefs();addFlatRefs(){return bu(this.flatRefs,this.prevariadic.flatMap((a,b)=>i(a.node.flatRefs.map(a=>bs([`${b}`,...a.path],a.node)),bs([`${b}`],a.node)))),bu(this.flatRefs,this.variadicOrPostfix.flatMap(a=>i(a.flatRefs.map(a=>bs([ap.intrinsic.nonNegativeIntegerString.internal,...a.path],a.node)),bs([ap.intrinsic.nonNegativeIntegerString.internal],a)))),this.flatRefs}isVariadicOnly=this.prevariadic.length+this.postfixLength===0;minVariadicLength=this.inner.minVariadicLength??0;minLength=this.prefixLength+this.minVariadicLength+this.postfixLength;minLengthNode=0===this.minLength?null:this.$.node("minLength",this.minLength);maxLength=this.variadic?null:this.tuple.length;maxLengthNode=null===this.maxLength?null:this.$.node("maxLength",this.maxLength);impliedSiblings=this.minLengthNode?this.maxLengthNode?[this.minLengthNode,this.maxLengthNode]:[this.minLengthNode]:this.maxLengthNode?[this.maxLengthNode]:[];defaultValueMorphs=dV(this);defaultValueMorphsReference=this.defaultValueMorphs.length?aM(this.defaultValueMorphs):void 0;elementAtIndex(a,b){if(b<this.prevariadic.length)return this.tuple[b];let c=a.length-this.postfixLength;return b>=c?{kind:"postfix",node:this.postfix[b-c]}:{kind:"variadic",node:this.variadic??r(`Unexpected attempt to access index ${b} on ${this}`)}}traverseAllows=(a,b)=>{for(let c=0;c<a.length;c++)if(!this.elementAtIndex(a,c).node.traverseAllows(a[c],b))return!1;return!0};traverseApply=(a,b)=>{let c=0;for(;c<a.length;c++)bm(c,()=>this.elementAtIndex(a,c).node.traverseApply(a[c],b),b)};get element(){return this.cacheGetter("element",this.$.node("union",this.children))}compile(a){if(this.prefix)for(let[b,c]of this.prefix.entries())a.traverseKey(`${b}`,`data[${b}]`,c);for(let[b,c]of this.defaultablesAndOptionals.entries()){let d=`${b+this.prefixLength}`;a.if(`${d} >= data.length`,()=>"Allows"===a.traversalKind?a.return(!0):a.return()),a.traverseKey(d,`data[${d}]`,c)}if(this.variadic&&(this.postfix&&a.const("firstPostfixIndex",`data.length${this.postfix?`- ${this.postfix.length}`:""}`),a.for(`i < ${this.postfix?"firstPostfixIndex":"data.length"}`,()=>a.traverseKey("i","data[i]",this.variadic),this.prevariadic.length),this.postfix))for(let[b,c]of this.postfix.entries()){let d=`firstPostfixIndex + ${b}`;a.traverseKey(d,`data[${d}]`,c)}"Allows"===a.traversalKind&&a.return(!0)}_transform(a,b){b.path.push(ap.intrinsic.nonNegativeIntegerString.internal);let c=super._transform(a,b);return b.path.pop(),c}expression=this.description;reduceJsonSchema(a,b){if(this.prevariadic.length&&(a.prefixItems=this.prevariadic.map(a=>{let c=a.node.toJsonSchemaRecurse(b);if("defaultables"===a.kind){let d="function"==typeof a.default?a.default():a.default;c.default=ap.intrinsic.jsonData.allows(d)?d:b.fallback.defaultValue({code:"defaultValue",base:c,value:d})}return c})),this.minLength&&(a.minItems=this.minLength),this.variadic){let c=Object.assign(a,{items:this.variadic.toJsonSchemaRecurse(b)});if(this.maxLength&&(c.maxItems=this.maxLength),this.postfix){let d=this.postfix.map(a=>a.toJsonSchemaRecurse(b));a=b.fallback.arrayPostfix({code:"arrayPostfix",base:c,elements:d})}}else a.items=!1,delete a.maxItems;return a}}let dU={},dV=a=>{if(!a.defaultables)return[];let b=[],c="[",d=a.prefixLength+a.defaultablesLength-1;for(let e=a.prefixLength;e<=d;e++){let[d,f]=a.defaultables[e-a.prefixLength];b.push(cR(e,d,f)),c+=`${e}: ${d.id} = ${a8(f)}, `}return c+="]",dU[c]??=b},dW={implementation:dS,Node:dT},dX=a=>{let b=[];if(a.prefix)for(let c of a.prefix)b.push({kind:"prefix",node:c});if(a.defaultables)for(let[c,d]of a.defaultables)b.push({kind:"defaultables",node:c,default:d});if(a.optionals)for(let c of a.optionals)b.push({kind:"optionals",node:c});if(a.variadic&&b.push({kind:"variadic",node:a.variadic}),a.postfix)for(let c of a.postfix)b.push({kind:"postfix",node:c});return b},dY=a=>a.reduce((a,b)=>("variadic"===b.kind?a.variadic=b.node:"defaultables"===b.kind?a.defaultables=i(a.defaultables,[[b.node,b.default]]):a[b.kind]=i(a[b.kind],b.node),a),{}),dZ="A postfix required element cannot follow an optional or defaultable element",d$="A postfix element requires a variadic element",d_=a=>{let[b,...c]=a.l,[d,...e]=a.r;if(!b||!d)return a;let f=c[c.length-1]?.kind==="postfix",g=e[e.length-1]?.kind==="postfix",h="prefix"===b.kind||"prefix"===d.kind?"prefix":"postfix"===b.kind||"postfix"===d.kind?"postfix":"variadic"===b.kind&&"variadic"===d.kind?"variadic":f||g?"prefix":"defaultables"===b.kind||"defaultables"===d.kind?"defaultables":"optionals";if("prefix"===b.kind&&"variadic"===d.kind&&g){let b=d_({...a,fixedVariants:[],r:e.map(a=>({...a,kind:"prefix"}))});0===b.disjoint.length&&a.fixedVariants.push(b)}else if("prefix"===d.kind&&"variadic"===b.kind&&f){let b=d_({...a,fixedVariants:[],l:c.map(a=>({...a,kind:"prefix"}))});0===b.disjoint.length&&a.fixedVariants.push(b)}let i=bD(b.node,d.node,a.ctx);if(i instanceof bw)if("prefix"===h||"postfix"===h)a.disjoint.push(...i.withPrefixKey("prefix"===h?a.result.length:`-${c.length+1}`,d0(b)&&d0(d)?"required":"optional")),a.result=[...a.result,{kind:h,node:ap.intrinsic.never.internal}];else if("optionals"===h||"defaultables"===h)return a;else return d_({...a,fixedVariants:[],l:c.map(a=>({...a,kind:"prefix"})),r:c.map(a=>({...a,kind:"prefix"}))});else"defaultables"===h?("defaultables"===b.kind&&"defaultables"===d.kind&&b.default!==d.default&&u(cL(b.default,d.default)),a.result=[...a.result,{kind:h,node:i,default:"defaultables"===b.kind?b.default:"defaultables"===d.kind?d.default:r(`Unexpected defaultable intersection from ${b.kind} and ${d.kind} elements.`)}]):a.result=[...a.result,{kind:h,node:i}];let j=a.l.length,k=a.r.length;return("variadic"!==b.kind||j>=k&&("variadic"===d.kind||1===k))&&(a.l=c),("variadic"!==d.kind||k>=j&&("variadic"===b.kind||1===j))&&(a.r=e),d_(a)},d0=a=>"prefix"===a.kind||"postfix"===a.kind,d1=a=>b=>{if(b.props.length||b.index){let c=b.index?.map(b=>b[a])??[];for(let d of b.props)c.push(d[a]);b.undeclared&&c.push(`+ (undeclared): ${b.undeclared}`);let d=`{ ${c.join(", ")} }`;return b.sequence?`${d} & ${b.sequence.description}`:d}return b.sequence?.description??"{}"},d2=d1("description"),d3=d1("expression"),d4=(a,b,c)=>{let d=a.required?"required":"optional";if(!b.signature.allows(a.key))return null;let e=bB(a.value,b.value,c);return e instanceof bw?"optional"===d?c.node("optional",{key:a.key,value:ap.intrinsic.never.internal}):e.withPrefixKey(a.key,a.kind):null},d5=ba({kind:"structure",hasAssociatedError:!1,normalize:a=>a,applyConfig:(a,b)=>a.undeclared||"ignore"===b.onUndeclaredKey?a:{...a,undeclared:b.onUndeclaredKey},keys:{required:{child:!0,parse:bK("required"),reduceIo:(a,b,c)=>{b.required=i(b.required,c.map(b=>"in"===a?b.rawIn:b.rawOut))}},optional:{child:!0,parse:bK("optional"),reduceIo:(a,b,c)=>{if("in"===a){b.optional=c.map(a=>a.rawIn);return}for(let a of c)b[a.outProp.kind]=i(b[a.outProp.kind],a.outProp.rawOut)}},index:{child:!0,parse:bK("index")},sequence:{child:!0,parse:bK("sequence")},undeclared:{parse:a=>"ignore"===a?void 0:a,reduceIo:(a,b,c)=>{if("reject"===c){b.undeclared="reject";return}"in"===a?delete b.undeclared:b.undeclared="reject"}}},defaults:{description:d2},intersections:{structure:(a,b,c)=>{let d={...a.inner},e={...b.inner},f=new bw;if(a.undeclared){let d=a.keyof();for(let a of b.requiredKeys)d.allows(a)||f.add("presence",ap.intrinsic.never.internal,b.propsByKey[a].value,{path:[a]});e.optional&&(e.optional=e.optional.filter(a=>d.allows(a.key))),e.index&&(e.index=e.index.flatMap(a=>{if(a.signature.extends(d))return a;let b=bB(d,a.signature,c.$);if(b instanceof bw)return[];let f=ed(b,a.value,c.$);return f.required&&(e.required=j(e.required,f.required)),f.optional&&(e.optional=j(e.optional,f.optional)),f.index??[]}))}if(b.undeclared){let e=b.keyof();for(let b of a.requiredKeys)e.allows(b)||f.add("presence",a.propsByKey[b].value,ap.intrinsic.never.internal,{path:[b]});d.optional&&(d.optional=d.optional.filter(a=>e.allows(a.key))),d.index&&(d.index=d.index.flatMap(a=>{if(a.signature.extends(e))return a;let b=bB(e,a.signature,c.$);if(b instanceof bw)return[];let f=ed(b,a.value,c.$);return f.required&&(d.required=j(d.required,f.required)),f.optional&&(d.optional=j(d.optional,f.optional)),f.index??[]}))}let g={};(a.undeclared||b.undeclared)&&(g.undeclared="reject"===a.undeclared||"reject"===b.undeclared?"reject":"delete");let h=bL({kind:"structure",baseInner:g,l:bM(d),r:bM(e),roots:[],ctx:c});return(h instanceof bw&&f.push(...h),f.length)?f:h}},reduce:(a,b)=>{if(!a.required&&!a.optional)return;let c={},d=!1,e=a.optional?[...a.optional]:[];if(a.required)for(let d=0;d<a.required.length;d++){let e=a.required[d];if(e.key in c&&u(eg(e.key)),c[e.key]=!0,a.index)for(let c of a.index){let a=d4(e,c,b);if(a instanceof bw)return a}}if(a.optional)for(let f=0;f<a.optional.length;f++){let g=a.optional[f];if(g.key in c&&u(eg(g.key)),c[g.key]=!0,a.index)for(let c of a.index){let a=d4(g,c,b);if(a instanceof bw)return a;null!==a&&(e[f]=a,d=!0)}}if(d)return b.node("structure",{...a,optional:e},{prereduced:!0})}});class d6 extends bI{impliedBasis=ap.intrinsic.object.internal;impliedSiblings=this.children.flatMap(a=>a.impliedSiblings??[]);props=j(this.required,this.optional);propsByKey=Q(this.props,(a,b)=>[b.key,b]);propsByKeyReference=aM(this.propsByKey);expression=d3(this);requiredKeys=this.required?.map(a=>a.key)??[];optionalKeys=this.optional?.map(a=>a.key)??[];literalKeys=[...this.requiredKeys,...this.optionalKeys];_keyof;keyof(){if(this._keyof)return this._keyof;let a=this.$.units(this.literalKeys).branches;if(this.index)for(let{signature:b}of this.index)a=a.concat(b.branches);return this._keyof=this.$.node("union",a)}map(a){return this.$.node("structure",this.props.flatMap(a).reduce((a,b)=>{let c=this.propsByKey[b.key];if(aW(b))return"required"!==b.kind&&"optional"!==b.kind?u(`Map result must have kind "required" or "optional" (was ${b.kind})`):(a[b.kind]=i(a[b.kind],b),a);let d=b.kind??c?.kind??"required",e=Q(b,(a,b)=>a in cO.implementation.keys?[a,b]:[]);return a[d]=i(a[d],this.$.node(d,e)),a},{}))}assertHasKeys(a){let b=a.filter(a=>!cX(a,this.keyof()));if(b.length)return u(ef(this.expression,b))}get(a,...b){let c,d=!1,e=eb(a);if(("string"==typeof e||"symbol"==typeof e)&&this.propsByKey[e]&&(c=this.propsByKey[e].value,d=this.propsByKey[e].required),this.index)for(let a of this.index)cX(e,a.signature)&&(c=c?.and(a.value)??a.value);if(this.sequence&&cX(e,ap.intrinsic.nonNegativeIntegerString))if(aV(e,"root"))this.sequence.variadic&&(c=c?.and(this.sequence.element)??this.sequence.element);else{let a=Number.parseInt(e);if(a<this.sequence.prevariadic.length){let b=this.sequence.prevariadic[a].node;c=c?.and(b)??b,d||=a<this.sequence.prefixLength}else if(this.sequence.variadic){let a=this.$.node("union",this.sequence.variadicOrPostfix);c=c?.and(a)??a}}if(!c)return this.sequence?.variadic&&aV(e,"root")&&e.extends(ap.intrinsic.number)?u(ec(e.expression,this.sequence.expression)):u(ef(this.expression,[e]));let f=c.get(...b);return d?f:f.or(ap.intrinsic.undefined)}pick(...a){return this.assertHasKeys(a),this.$.node("structure",this.filterKeys("pick",a))}omit(...a){return this.assertHasKeys(a),this.$.node("structure",this.filterKeys("omit",a))}optionalize(){let{required:a,...b}=this.inner;return this.$.node("structure",{...b,optional:this.props.map(a=>a.hasKind("required")?this.$.node("optional",a.inner):a)})}require(){let{optional:a,...b}=this.inner;return this.$.node("structure",{...b,required:this.props.map(a=>a.hasKind("optional")?{key:a.key,value:a.value}:a)})}merge(a){let b=this.filterKeys("omit",[a.keyof()]);return a.required&&(b.required=i(b.required,a.required)),a.optional&&(b.optional=i(b.optional,a.optional)),a.index&&(b.index=i(b.index,a.index)),a.sequence&&(b.sequence=a.sequence),a.undeclared?b.undeclared=a.undeclared:delete b.undeclared,this.$.node("structure",b)}filterKeys(a,b){let c=aT(this.inner),d=c=>{let d=b.some(a=>cX(c,a));return"pick"===a?d:!d};return c.required&&(c.required=c.required.filter(a=>d(a.key))),c.optional&&(c.optional=c.optional.filter(a=>d(a.key))),c.index&&(c.index=c.index.filter(a=>d(a.signature))),c}traverseAllows=(a,b)=>this._traverse("Allows",a,b);traverseApply=(a,b)=>this._traverse("Apply",a,b);_traverse=(a,b,c)=>{let d=c?.currentErrorCount??0;for(let e=0;e<this.props.length;e++)if("Allows"===a){if(!this.props[e].traverseAllows(b,c))return!1}else if(this.props[e].traverseApply(b,c),c.failFast&&c.currentErrorCount>d)return!1;if(this.sequence){if("Allows"===a){if(!this.sequence.traverseAllows(b,c))return!1}else if(this.sequence.traverseApply(b,c),c.failFast&&c.currentErrorCount>d)return!1}if(this.index||"reject"===this.undeclared){let e=Object.keys(b);e.push(...Object.getOwnPropertySymbols(b));for(let f=0;f<e.length;f++){let g=e[f];if(this.index){for(let e of this.index)if(e.signature.traverseAllows(g,c)){if("Allows"===a){if(!bm(g,()=>e.value.traverseAllows(b[g],c),c))return!1}else if(bm(g,()=>e.value.traverseApply(b[g],c),c),c.failFast&&c.currentErrorCount>d)return!1}}if("reject"===this.undeclared&&!this.declaresKey(g)&&("Allows"===a||(c.errorFromNodeContext({code:"predicate",expected:"removed",actual:"",relativePath:[g],meta:this.meta}),c.failFast)))return!1}}return this.structuralMorph&&c&&!c.hasError()&&c.queueMorphs([this.structuralMorph]),!0};get defaultable(){return this.cacheGetter("defaultable",this.optional?.filter(a=>a.hasDefault())??[])}declaresKey=a=>a in this.propsByKey||this.index?.some(b=>b.signature.allows(a))||void 0!==this.sequence&&ap.intrinsic.nonNegativeIntegerString.allows(a);_compileDeclaresKey(a){let b=[];if(this.props.length&&b.push(`k in ${this.propsByKeyReference}`),this.index)for(let c of this.index)b.push(a.invoke(c.signature,{kind:"Allows",arg:"k"}));return this.sequence&&b.push("$ark.intrinsic.nonNegativeIntegerString.allows(k)"),b.join(" || ")||"false"}get structuralMorph(){return this.cacheGetter("structuralMorph",d8(this))}structuralMorphRef=this.structuralMorph&&aM(this.structuralMorph);compile(a){for(let b of("Apply"===a.traversalKind&&a.initializeErrorCount(),this.props))a.check(b),"Apply"===a.traversalKind&&a.returnIfFailFast();if(this.sequence&&(a.check(this.sequence),"Apply"===a.traversalKind&&a.returnIfFailFast()),(this.index||"reject"===this.undeclared)&&(a.const("keys","Object.keys(data)"),a.line("keys.push(...Object.getOwnPropertySymbols(data))"),a.for("i < keys.length",()=>this.compileExhaustiveEntry(a))),"Allows"===a.traversalKind)return a.return(!0);this.structuralMorphRef&&a.if("ctx && !ctx.hasError()",()=>(a.line("ctx.queueMorphs(["),d9(a,this),a.line("])")))}compileExhaustiveEntry(a){if(a.const("k","keys[i]"),this.index)for(let b of this.index)a.if(`${a.invoke(b.signature,{arg:"k",kind:"Allows"})}`,()=>a.traverseKey("k","data[k]",b.value));return"reject"===this.undeclared&&a.if(`!(${this._compileDeclaresKey(a)})`,()=>"Allows"===a.traversalKind?a.return(!1):a.line(`ctx.errorFromNodeContext({ code: "predicate", expected: "removed", actual: "", relativePath: [k], meta: ${this.compiledMeta} })`).if("ctx.failFast",()=>a.return())),a}reduceJsonSchema(a,b){switch(a.type){case"object":return this.reduceObjectJsonSchema(a,b);case"array":let c=this.sequence?.reduceJsonSchema(a,b)??a;if(this.props.length||this.index)return b.fallback.arrayObject({code:"arrayObject",base:c,object:this.reduceObjectJsonSchema({type:"object"},b)});return c;default:return bc.throwInternalOperandError("structure",a)}}reduceObjectJsonSchema(a,b){if(this.props.length){for(let c of(a.properties={},this.props)){let d=c.value.toJsonSchemaRecurse(b);if("symbol"==typeof c.key){b.fallback.symbolKey({code:"symbolKey",base:a,key:c.key,value:d,optional:c.optional});continue}if(c.hasDefault()){let a="function"==typeof c.default?c.default():c.default;d.default=ap.intrinsic.jsonData.allows(a)?a:b.fallback.defaultValue({code:"defaultValue",base:d,value:a})}a.properties[c.key]=d}this.requiredKeys.length&&a.properties&&(a.required=this.requiredKeys.filter(b=>"string"==typeof b&&b in a.properties))}if(this.index)for(let c of this.index){let d=c.value.toJsonSchemaRecurse(b);if(c.signature.equals(ap.intrinsic.string)){a.additionalProperties=d;continue}for(let e of c.signature.branches){if(!e.extends(ap.intrinsic.string)){a=b.fallback.symbolKey({code:"symbolKey",base:a,key:null,value:d,optional:!1});continue}let c={type:"string"};if(e.hasKind("morph")&&(c=b.fallback.morph({code:"morph",base:e.rawIn.toJsonSchemaRecurse(b),out:e.rawOut.toJsonSchemaRecurse(b)})),!e.hasKind("intersection"))return r(`Unexpected index branch kind ${e.kind}.`);let{pattern:f}=e.inner;if(f){let e=Object.assign(c,{pattern:f[0].rule});for(let a=1;a<f.length;a++)c=b.fallback.patternIntersection({code:"patternIntersection",base:e,pattern:f[a].rule});a.patternProperties??={},a.patternProperties[e.pattern]=d}}}return this.undeclared&&!a.additionalProperties&&(a.additionalProperties=!1),a}}let d7={},d8=a=>{let b=(a=>{let b="";for(let c=0;c<a.defaultable.length;c++)b+=a.defaultable[c].defaultValueMorphRef;if(a.sequence?.defaultValueMorphsReference&&(b+=a.sequence?.defaultValueMorphsReference),"delete"===a.undeclared){if(b+="delete !(",a.required)for(let c of a.required)b+=c.compiledKey+" | ";if(a.optional)for(let c of a.optional)b+=c.compiledKey+" | ";if(a.index)for(let c of a.index)b+=c.signature.id+" | ";if(a.sequence)if(null===a.sequence.maxLength)b+=eI.nonNegativeIntegerString.id;else for(let c=0;c<a.sequence.tuple.length;c++)b+=c+" | ";b+=")"}return b})(a);return b?d7[b]?d7[b]:d7[b]=(b,c)=>{for(let d=0;d<a.defaultable.length;d++)a.defaultable[d].key in b||a.defaultable[d].defaultValueMorph(b,c);if(a.sequence?.defaultables)for(let d=b.length-a.sequence.prefixLength;d<a.sequence.defaultables.length;d++)a.sequence.defaultValueMorphs[d](b,c);if("delete"===a.undeclared)for(let c in b)a.declaresKey(c)||delete b[c];return b}:void 0},d9=(a,b)=>{let c=b.defaultable.some(a=>2===a.defaultValueMorph.length)||b.sequence?.defaultValueMorphs.some(a=>2===a.length),d=`(data${c?", ctx":""})`;return a.block(`${d} => `,a=>{for(let c=0;c<b.defaultable.length;c++){let{serializedKey:e,defaultValueMorphRef:f}=b.defaultable[c];a.if(`!(${e} in data)`,a=>a.line(`${f}${d}`))}return b.sequence?.defaultables&&a.for(`i < ${b.sequence.defaultables.length}`,a=>a.set("data[i]",5),`data.length - ${b.sequence.prefixLength}`),"delete"===b.undeclared&&a.forIn("data",a=>a.if(`!(${b._compileDeclaresKey(a)})`,a=>a.line("delete data[k]"))),a.return("data")})},ea={implementation:d5,Node:d6},eb=a=>(aV(a,"root")&&a.hasKind("unit")&&(a=a.unit),"number"==typeof a&&(a=`${a}`),a),ec=(a,b)=>`${a} is not allowed as an array index on ${b}. Use the 'nonNegativeIntegerString' keyword instead.`,ed=(a,b,c)=>{let[d,e]=((a,b)=>{let c=[[],[]];for(let d of a)b(d)?c[0].push(d):c[1].push(d);return c})(a.branches,a=>a.hasKind("unit"));if(!d.length)return{index:c.node("index",{signature:a,value:b})};let f={};for(let a of d){let d=c.node("required",{key:a.unit,value:b});f[d.kind]=i(f[d.kind],d)}return e.length&&(f.index=c.node("index",{signature:e,value:b})),f},ee=a=>aV(a,"root")?a.expression:aw(a),ef=(a,b)=>`Key${1===b.length?"":"s"} ${b.map(ee).join(", ")} ${1===b.length?"does":"do"} not exist on ${a}`,eg=a=>`Duplicate key ${aO(a)}`,eh={...ct,alias:c4.implementation,domain:c8.implementation,unit:dI.implementation,proto:dk.implementation,union:dv.implementation,morph:dg.implementation,intersection:db.implementation,divisor:bW.implementation,pattern:cx.implementation,predicate:bT.implementation,required:dR.implementation,optional:cO.implementation,index:dM.implementation,sequence:dW.implementation,structure:ea.implementation};ap.defaultConfig=(a=>{let b=Object.keys(a).sort(),c={};for(let d=0;d<b.length;d++)c[b[d]]=a[b[d]];return c})(Object.assign(Q(eh,(a,b)=>[a,b.defaults]),{jitless:U(),clone:a=>P(a,new Map),onUndeclaredKey:"ignore",exactOptionalPropertyTypes:!0,numberAllowsNaN:!1,dateAllowsInvalid:!1,onFail:null,keywords:{},toJsonSchema:bc.defaultConfig})),ap.resolvedConfig=bd(ap.defaultConfig,ap.config);let ei={...cu,alias:c4.Node,domain:c8.Node,unit:dI.Node,proto:dk.Node,union:dv.Node,morph:dg.Node,intersection:db.Node,divisor:bW.Node,pattern:cx.Node,predicate:bT.Node,required:dR.Node,optional:cO.Node,index:dM.Node,sequence:dW.Node,structure:ea.Node};class ej extends y{get[aU](){return"module"}}let ek=(a,b)=>new ej(Q(a,(a,c)=>[a,aV(c,"module")?ek(c,b):b.bindReference(c)])),el=a=>`#${a} duplicates public alias ${a}`,em={};ap.ambient??={};let en="function $",eo=(a,b)=>{let c=b.write(en,4),d=b.compile()();for(let b of a)b.precompilation||(b.traverseAllows=d[`${b.id}Allows`].bind(d),b.isRoot()&&!b.allowsRequiresContext&&(b.allows=b.traverseAllows),b.traverseApply=d[`${b.id}Apply`].bind(d),d[`${b.id}Optimistic`]&&(b.traverseOptimistic=d[`${b.id}Optimistic`].bind(d)),b.precompilation=c)},ep=a=>new aN().return(a.reduce((a,b)=>{let c=new aS({kind:"Allows"}).indent();b.compile(c);let d=c.write(`${b.id}Allows`),e=new aS({kind:"Apply"}).indent();b.compile(e);let f=e.write(`${b.id}Apply`),g=`${a}${d},
${f},
`;if(!b.hasKind("union"))return g;let h=new aS({kind:"Allows",optimistic:!0}).indent();b.compile(h);let i=h.write(`${b.id}Optimistic`);return`${g}${i},
`},"{\n")+"}");class eq{config;resolvedConfig;name;get[aU](){return"scope"}referencesById={};references=[];resolutions={};exportedNames=[];aliases={};resolved=!1;nodesByHash={};intrinsic;constructor(a,b){for(let[c,d]of(this.config=bd(ap.config,b),this.resolvedConfig=bd(ap.resolvedConfig,b),this.name=this.resolvedConfig.name??`anonymousScope${Object.keys(em).length}`,this.name in em&&u(`A Scope already named ${this.name} already exists`),em[this.name]=this,Object.entries(a).map(a=>this.preparseOwnAliasEntry(...a)))){let a=c;if("#"===c[0]?((a=c.slice(1))in this.aliases&&u(el(a)),this.aliases[a]=d):(a in this.aliases&&u(el(c)),this.aliases[a]=d,this.exportedNames.push(a)),!aV(d,"module")&&!aV(d,"generic")&&!R(d)){let b=this.preparseOwnDefinitionFormat(d,{alias:a});this.resolutions[a]=aV(b,"root")?this.bindReference(b):this.createParseContext(b).id}}d??=this.node("union",{branches:["string","number","object","bigint","symbol",{unit:!0},{unit:!1},{unit:void 0},{unit:null}]},{prereduced:!0}),this.nodesByHash[d.hash]=this.node("intersection",{},{prereduced:!0}),this.intrinsic=ap.intrinsic?Q(ap.intrinsic,(a,b)=>a.startsWith("json")?[]:[a,this.bindReference(b)]):{}}cacheGetter(a,b){return Object.defineProperty(this,a,{value:b}),b}get internal(){return this}_json;get json(){return this._json||this.export(),this._json}defineSchema(a){return a}generic=(...a)=>{let b=this;return(c,d)=>new bP(a,d?new bO(c):c,b,b,d??null)};units=(a,b)=>{let c=[];for(let b of a)c.includes(b)||c.push(b);let d=c.map(a=>this.node("unit",{unit:a},b));return this.node("union",d,{...b,prereduced:!0})};lazyResolutions=[];lazilyResolve(a,b){let c=this.node("alias",{reference:b??"synthetic",resolve:a},{prereduced:!0});return this.resolved||this.lazyResolutions.push(c),c}schema=(a,b)=>this.finalize(this.parseSchema(a,b));parseSchema=(a,b)=>this.node(cy(a),a,b);preparseNode(a,b,c){let d="string"==typeof a?a:cy(b,a);if(aW(b)&&b.kind===d)return b;if("alias"!==d||c?.prereduced){if("union"===d&&m(b,"object")){let a,c=L(a=b)?a:"branches"in a&&L(a.branches)?a.branches:void 0;c?.length===1&&(d=cy(b=c[0]))}}else{let{reference:a}=c4.implementation.normalize(b,this);if(a.startsWith("$")){let c=this.resolveRoot(a.slice(1));b=c,d=c.kind}}if(aW(b)&&b.kind===d)return b;let e=eh[d],f=e.normalize?.(b,this)??b;if(aW(f)){let a,b;return f.kind===d?f:(a=d,b=f.kind,u(`Node of kind ${b} is not valid as a ${a} definition`))}return{...c,$:this,kind:d,def:f,prefix:c.alias??d}}bindReference(a){let b;return b=aW(a)?a.$===this?a:new a.constructor(a.attachments,this):a.$===this?a:new bP(a.params,a.bodyDef,a.$,this,a.hkt),this.resolved||Object.assign(this.referencesById,b.referencesById),b}resolveRoot(a){return this.maybeResolveRoot(a)??u(ey(a))}maybeResolveRoot(a){let b=this.maybeResolve(a);if(!aV(b,"generic"))return b}maybeResolveSubalias(a){return eu(this.aliases,a)??eu(this.ambient,a)}get ambient(){return ap.ambient}maybeResolve(a){let b=this.resolutions[a];if(b){if("string"!=typeof b)return this.bindReference(b);let c=cD[b];if(aV(c,"root"))return this.resolutions[a]=c;if(aV(c,"context")){if("resolving"===c.phase)return this.node("alias",{reference:`$${a}`},{prereduced:!0});if("resolved"===c.phase)return r(`Unexpected resolved context for was uncached by its scope: ${aw(c)}`);c.phase="resolving";let b=this.bindReference(this.parseOwnDefinitionFormat(c.def,c));return c.phase="resolved",cD[b.id]=b,cD[c.id]=b,this.resolutions[a]=b}return r(`Unexpected nodesById entry for ${b}: ${aw(c)}`)}let c=this.aliases[a]??this.ambient?.[a];return c?aV(c=this.normalizeRootScopeValue(c),"generic")?this.resolutions[a]=this.bindReference(c):aV(c,"module")?(c.root||u(eA(a)),this.resolutions[a]=this.bindReference(c.root)):this.resolutions[a]=this.parse(c,{alias:a}):this.maybeResolveSubalias(a)}createParseContext(a){let b=a.id??cE(a.prefix);return cD[b]=Object.assign(a,{[aU]:"context",$:this,id:b,phase:"unresolved"})}traversal(a){return new bl(a,this.resolvedConfig)}import(...a){return new ej(Q(this.export(...a),(a,b)=>[`#${a}`,b]))}precompilation;_exportedResolutions;_exports;export(...a){if(!this._exports){for(let a of(this._exports={},this.exportedNames)){let b=this.aliases[a];this._exports[a]=aV(b,"module")?ek(b,this):es(this.maybeResolve(a))}for(let a of this.lazyResolutions)a.resolution;if(this._exportedResolutions=ex(this,this._exports),this._json=et(this._exportedResolutions),Object.assign(this.resolutions,this._exportedResolutions),this.references=Object.values(this.referencesById),!this.resolvedConfig.jitless){let a=ep(this.references);this.precompilation=a.write(en,4),eo(this.references,a)}this.resolved=!0}return new ej(Q(a.length?a:this.exportedNames,(a,b)=>[b,this._exports[b]]))}resolve(a){return this.export()[a]}node=(a,b,c={})=>{let d=this.preparseNode(a,b,c);if(aW(d))return this.bindReference(d);let e=this.createParseContext(d),f=cF(e),g=this.bindReference(f);return cD[e.id]=g};parse=(a,b={})=>this.finalize(this.parseDefinition(a,b));parseDefinition(a,b={}){var c,d;if(aV(a,"root"))return this.bindReference(a);let e=this.preparseOwnDefinitionFormat(a,b);if(aV(e,"root"))return this.bindReference(e);let f=this.createParseContext(e);cD[f.id]=f;let g=this.bindReference(this.parseOwnDefinitionFormat(a,f));return g.isCyclic&&(c=g,d=f.id,g=c.id===d?c:(aW(cD[d])&&r(`Unexpected attempt to overwrite node id ${d}`),cG({id:d,kind:c.kind,inner:c.inner,meta:c.meta,$:c.$,ignoreCache:!0}))),cD[f.id]=g,g}finalize(a){let b;return es(a),a.precompilation||this.resolvedConfig.jitless||eo(b=a.references,ep(b)),a}}class er extends eq{parseOwnDefinitionFormat(a,b){return cF(b)}preparseOwnDefinitionFormat(a,b){return this.preparseNode(cy(a),a,b)}preparseOwnAliasEntry(a,b){return[a,b]}normalizeRootScopeValue(a){return a}}let es=a=>{for(let b of a.references.filter(a=>a.hasKind("alias")))for(let c of(Object.assign(b.referencesById,b.resolution.referencesById),a.references))b.id in c.referencesById&&Object.assign(c.referencesById,b.referencesById);return a},et=a=>Q(a,(a,b)=>[a,aV(b,"root")||aV(b,"generic")?b.json:aV(b,"module")?et(b):r(`Unexpected resolution ${aw(b)}`)]),eu=(a,b)=>{let c=b.indexOf(".");if(-1===c)return;let d=b.slice(0,c),e=a[d];if(void 0===e)return;if(!aV(e,"module"))return u(ez(d));let f=b.slice(c+1),g=e[f];return void 0===g?eu(e,f):aV(g,"root")||aV(g,"generic")?g:aV(g,"module")?g.root??u(eA(b)):void r(`Unexpected resolution for alias '${b}': ${aw(g)}`)},ev=(a,b)=>new er(a,b),ew=new er({}),ex=(a,b)=>{let c={};for(let d in b){let e=b[d];aV(e,"module")?Object.assign(c,Q(ex(a,e),(a,b)=>[`${d}.${a}`,b])):aV(e,"root")||aV(e,"generic")?c[d]=e:r(`Unexpected scope resolution ${aw(e)}`)}return c},ey=a=>`'${a}' is unresolvable`,ez=a=>`'${a}' must reference a module to be accessed using dot syntax`,eA=a=>`Reference to submodule '${a}' must specify an alias`;ew.export();let eB=ew.schema,eC=ew.node;ew.defineSchema;let eD=ew.generic,eE="^(?:0|[1-9]\\d*)$";aM(new RegExp(eE));let eF=ev({bigint:"bigint",boolean:[{unit:!1},{unit:!0}],false:{unit:!1},never:[],null:{unit:null},number:"number",object:"object",string:"string",symbol:"symbol",true:{unit:!0},unknown:{},undefined:{unit:void 0},Array,Date},{prereducedAliases:!0}).export();ap.intrinsic={...eF};let eG=ev({integer:{domain:"number",divisor:1},lengthBoundable:["string",Array],key:["string","symbol"],nonNegativeIntegerString:{domain:"string",pattern:eE}},{prereducedAliases:!0}).export();Object.assign(ap.intrinsic,eG);let eH=ev({jsonPrimitive:["string","number",{unit:!0},{unit:!1},{unit:null}],jsonObject:{domain:"object",index:{signature:"string",value:"$jsonData"}},jsonData:["$jsonPrimitive","$jsonObject"]},{prereducedAliases:!0}).export(),eI={...eF,...eG,...eH,emptyStructure:eC("structure",{},{prereduced:!0})};ap.intrinsic={...eI};let eJ=(a,b)=>new RegExp(a,b);Object.assign(eJ,{as:eJ});let eK=a=>"Invalid Date"!==a.toString(),eL=a=>`'${a}' could not be parsed by the Date constructor`,eM=(a,b)=>{let c=a.scanner.shiftUntilEscapable(eQ[eP[b]]);if(""===a.scanner.lookahead)return a.error(eS(c,b));if(a.scanner.shift(),"/"===b){try{new RegExp(c)}catch(a){u(String(a))}a.root=a.ctx.$.node("intersection",{domain:"string",pattern:c},{prereduced:!0})}else if(x(b,eN))a.root=a.ctx.$.node("unit",{unit:c});else{let b=((a,b)=>{let c=new Date(a);if(eK(c))return c;let d=ao(a,"number",void 0);if(void 0!==d){let a=new Date(d);if(eK(a))return a}return b?u(!0===b?eL(a):b):void 0})(c,eL(c));a.root=a.ctx.$.node("unit",{meta:c,unit:b})}},eN={"'":1,'"':1},eO={"/":1,"'":1,'"':1},eP={"d'":"'",'d"':'"',"'":"'",'"':'"',"/":"/"},eQ={"'":a=>"'"===a.lookahead,'"':a=>'"'===a.lookahead,"/":a=>"/"===a.lookahead},eR={'"':"double-quote","'":"single-quote","/":"forward slash"},eS=(a,b)=>`${b}${a} requires a closing ${eR[eP[b]]}`,eT="Optional definitions like 'string?' are only valid as properties in an object or tuple",eU="Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple",eV={"<":1,">":1,"=":1,"|":1,"&":1,")":1,"[":1,"%":1,",":1,":":1,"?":1,"#":1,...$},eW=(a,b,c,d)=>{let e=c.parseUntilFinalizer();return(d.push(e.root),">"===e.finalizer)?d.length!==b.params.length?c.error(eX(a,b.names,d.map(a=>a.expression))):d:","===e.finalizer?eW(a,b,c,d):e.error(aI(">"))},eX=(a,b,c)=>`${a}<${b.join(", ")}> requires exactly ${b.length} args (got ${c.length}${0===c.length?"":`: ${c.join(", ")}`})`,eY=(a,b)=>{let c;return eZ(a,b)??e$(a,b)??a.error(""===b?"#"===a.scanner.lookahead?(c=a.shiftedByOne().scanner.shiftUntilLookahead(eV),`Private type references should not include '#'. Use '${c}' instead.`):e_(a):ey(b))},eZ=(a,b)=>{if(a.ctx.args?.[b]){let c=a.ctx.args[b];return"string"!=typeof c?c:a.ctx.$.node("alias",{reference:c},{prereduced:!0})}let c=a.ctx.$.maybeResolve(b);return aV(c,"root")?c:void 0!==c?aV(c,"generic")?((a,b,c)=>{if(c.scanner.shiftUntilNonWhitespace(),"<"!==c.scanner.shift())return c.error(eX(a,b.names,[]));let d=eW(a,b,c,[]);return b(...d)})(b,c,a):u(`Unexpected resolution ${aw(c)}`):void 0},e$=(a,b)=>{let c=ao(b,"number",{...void 0,strict:!0});if(void 0!==c)return a.ctx.$.node("unit",{unit:c});let d=(a=>{let b;if("n"!==a[a.length-1])return;let c=a.slice(0,-1);try{b=BigInt(c)}catch{return}return ai.test(c)?b:ak.test(c)?u(an(a,"bigint")):void 0})(b);if(void 0!==d)return a.ctx.$.node("unit",{unit:d})},e_=a=>{let b=a.previousOperator();return b?e0(b,a.scanner.unscanned):e1(a.scanner.unscanned)},e0=(a,b="")=>`Token '${a}' requires a right operand${b?` before '${b}'`:""}`,e1=a=>`Expected an expression${a?` before '${a}'`:""}`,e2=a=>""===a.scanner.lookahead?a.error(e_(a)):"("===a.scanner.lookahead?a.shiftedByOne().reduceGroupOpen():a.scanner.lookaheadIsIn(eO)?eM(a,a.scanner.shift()):a.scanner.lookaheadIsIn($)?e2(a.shiftedByOne()):"d"===a.scanner.lookahead&&a.scanner.nextLookahead in eN?eM(a,`${a.scanner.shift()}${a.scanner.shift()}`):(a=>{let b=a.scanner.shiftUntilLookahead(eV);"keyof"===b?a.addPrefix("keyof"):a.root=eY(a,b)})(a),e3={">":!0,">=":!0},e4={"<":!0,"<=":!0},e5={"<":">",">":"<","<=":">=",">=":"<=","==":"=="},e6=a=>`Left-bounded expressions must specify their limits using < or <= (was ${a})`,e7={"<":1,">":1,"=":1},e8=(a,b,c,d)=>{let e;return c.extends(ap.intrinsic.number)?"number"!=typeof b?u(e9(a,b,d)):"=="===a?["min","max"]:">"===a[0]?["min"]:["max"]:c.extends(ap.intrinsic.lengthBoundable)?"number"!=typeof b?u(e9(a,b,d)):"=="===a?["exactLength"]:">"===a[0]?["minLength"]:["maxLength"]:c.extends(ap.intrinsic.Date)?"=="===a?["after","before"]:">"===a[0]?["after"]:["before"]:u((e=c.expression,`Bounded expression ${e} must be exactly one of number, string, Array, or Date`))},e9=(a,b,c)=>`Comparator ${"left"===c?e5[a]:a} must be ${"left"===c?"preceded":"followed"} by a corresponding literal (was ${b})`,fa=a=>`% operator must be followed by a non-zero integer literal (was ${a})`,fb=a=>{let b=a.scanner.shift();return""===b?a.finalize(""):"["===b?"]"===a.scanner.shift()?a.setRoot(a.root.array()):a.error(fd):"|"===b?">"===a.scanner.lookahead?a.shiftedByOne().pushRootToBranch("|>"):a.pushRootToBranch(b):"&"===b?a.pushRootToBranch(b):")"===b?a.finalizeGroup():((a,b)=>">"===a?"="===b[0]?"="===b[1]:""===b.trimStart()||x(b.trimStart()[0],eV):"="===a?"="!==b[0]:","===a||"?"===a)(b,a.scanner.unscanned)?a.finalize(b):x(b,e7)?((a,b)=>{let c=((a,b)=>a.scanner.lookaheadIs("=")?`${b}${a.scanner.shift()}`:b)(a,b);if(a.root.hasKind("unit")){if("number"==typeof a.root.unit){a.reduceLeftBound(a.root.unit,c),a.unsetRoot();return}if(a.root.unit instanceof Date){let b=`d'${a.root.description??a.root.unit.toISOString()}'`;a.unsetRoot(),a.reduceLeftBound(b,c);return}}return((a,b)=>{let c=a.unsetRoot(),d=a.scanner.location;a.parseOperand();let e=a.unsetRoot(),f=a.scanner.sliceChars(d,a.scanner.location);if(a.root=c,!e.hasKind("unit")||"number"!=typeof e.unit&&!(e.unit instanceof Date))return a.error(e9(b,f,"right"));let g=e.unit,h=1===b.length;for(let d of e8(b,"number"==typeof g?g:f,c,"right"))a.constrainRoot(d,"=="===b?{rule:g}:{rule:g,exclusive:h});if(!a.branches.leftBound)return;if(!x(b,e4))return a.error(e6(b));let i=e8(a.branches.leftBound.comparator,a.branches.leftBound.limit,c,"left");a.constrainRoot(i[0],(a=>({rule:(a=>"string"==typeof a&&"d"===a[0]&&("'"===a[1]||'"'===a[1])&&a[a.length-1]===a[1])(a.limit)?a.limit.slice(2,-1):a.limit,exclusive:1===a.comparator.length}))(a.branches.leftBound)),a.branches.leftBound=null})(a,c)})(a,b):"%"===b?(a=>{a.scanner.shiftUntilNonWhitespace();let b=a.scanner.shiftUntilLookahead(eV),c=ao(b,"integer",{errorOnFail:fa(b)});0===c&&a.error(fa(0)),a.root=a.root.constrain("divisor",c)})(a):"#"===b?(a=>{a.scanner.shiftUntilNonWhitespace();let b=a.scanner.shiftUntilLookahead(eV);a.root=a.root.brand(b)})(a):b in $?fb(a):a.error(fc(b))},fc=(a,b="")=>`'${a}' is not allowed here${b&&` (should be ${b})`}`,fd="Missing expected ']'",fe=(a,b)=>{let c=b.$.maybeResolveRoot(a);if(c)return c;if(a.endsWith("[]")){let c=b.$.maybeResolveRoot(a.slice(0,-2));if(c)return c.array()}let d=new fi(new aH(a),b),e=ff(d);return">"===d.finalizer&&u(fc(">")),e},ff=a=>{a.parseOperand();let b=fg(a).root;return b?("="===a.finalizer?b=(a=>{let b,c=a.unsetRoot();a.parseOperand();let d=a.unsetRoot();return d.hasKind("unit")?[c,"=",d.unit instanceof Date?()=>new Date(d.unit):d.unit]:a.error((b=d.expression,`Default value '${b}' must be a literal value`))})(a):"?"===a.finalizer&&(b=[b,"?"]),a.scanner.shiftUntilNonWhitespace(),a.scanner.lookahead&&u(fc(a.scanner.lookahead)),b):r(`Root was unexpectedly unset after parsing string '${a.scanner.scanned}'`)},fg=a=>{for(;void 0===a.finalizer;)fh(a);return a},fh=a=>a.hasRoot()?a.parseOperator():a.parseOperand();class fi{root;branches={prefixes:[],leftBound:null,intersection:null,union:null,pipe:null};finalizer;groups=[];scanner;ctx;constructor(a,b){this.scanner=a,this.ctx=b}error(a){return u(a)}hasRoot(){return void 0!==this.root}setRoot(a){this.root=a}unsetRoot(){let a=this.root;return this.root=void 0,a}constrainRoot(...a){this.root=this.root.constrain(a[0],a[1])}finalize(a){if(this.groups.length)return this.error(aI(")"));this.finalizeBranches(),this.finalizer=a}reduceLeftBound(a,b){let c=e5[b];if(!x(c,e3))return this.error(e6(b));if(this.branches.leftBound){let b,d;return this.error((b=this.branches.leftBound.limit,d=this.branches.leftBound.comparator,`An expression may have at most one left bound (parsed ${b}${e5[d]}, ${a}${e5[c]})`))}this.branches.leftBound={comparator:c,limit:a}}finalizeBranches(){if(this.assertRangeUnset(),this.branches.pipe){this.pushRootToBranch("|>"),this.root=this.branches.pipe;return}if(this.branches.union){this.pushRootToBranch("|"),this.root=this.branches.union;return}if(this.branches.intersection){this.pushRootToBranch("&"),this.root=this.branches.intersection;return}this.applyPrefixes()}finalizeGroup(){this.finalizeBranches();let a=this.groups.pop();if(!a){let a;return this.error((a=this.scanner.unscanned,`Unmatched )${""===a?"":` before ${a}`}`))}this.branches=a}addPrefix(a){this.branches.prefixes.push(a)}applyPrefixes(){for(;this.branches.prefixes.length;){let a=this.branches.prefixes.pop();this.root="keyof"===a?this.root.keyof():r(`Unexpected prefix '${a}'`)}}pushRootToBranch(a){this.assertRangeUnset(),this.applyPrefixes();let b=this.root;this.root=void 0,this.branches.intersection=this.branches.intersection?.rawAnd(b)??b,"&"!==a&&(this.branches.union=this.branches.union?.rawOr(this.branches.intersection)??this.branches.intersection,this.branches.intersection=null,"|"!==a&&(this.branches.pipe=this.branches.pipe?.rawPipeOnce(this.branches.union)??this.branches.union,this.branches.union=null))}parseUntilFinalizer(){return fg(new fi(this.scanner,this.ctx))}parseOperator(){return fb(this)}parseOperand(){return e2(this)}assertRangeUnset(){if(this.branches.leftBound){let a,b;return this.error((a=this.branches.leftBound.limit,b=this.branches.leftBound.comparator,`Left bounds are only valid when paired with right bounds (try ...${b}${a})`))}}reduceGroupOpen(){this.groups.push(this.branches),this.branches={prefixes:[],leftBound:null,union:null,intersection:null,pipe:null}}previousOperator(){return this.branches.leftBound?.comparator??this.branches.prefixes[this.branches.prefixes.length-1]??(this.branches.intersection?"&":this.branches.union?"|":this.branches.pipe?"|>":void 0)}shiftedByOne(){return this.scanner.shift(),this}}let fj=(a,b,c)=>{a.shiftUntilNonWhitespace();let d=a.shiftUntilLookahead(eV);return""===d?""===a.lookahead&&b.length?b:u("An empty string is not a valid generic parameter name"):(a.shiftUntilNonWhitespace(),fl(a,d,b,c))},fk="extends ",fl=(a,b,c,d)=>{if(a.shiftUntilNonWhitespace(),!a.unscanned.startsWith(fk))return","===a.lookahead&&a.shift(),c.push(b),fj(a,c,d);a.jumpForward(fk.length);let e=fg(new fi(a,d));return c.push([b,e.root]),fj(a,c,d)};class fm extends T{constructor(a){super((...b)=>{let c=b.indexOf(":"),d=-1===c?b.length-1:c-1,e=b.slice(0,d+1),f=a.parse(e).assertHasKind("intersection"),g=a.intrinsic.unknown;if(-1!==c){if(c!==b.length-2)return u(fo);g=a.parse(b[c+1])}return a=>new fn(a,f,g)},{attach:{$:a,raw:a.fn}})}}class fn extends T{raw;params;returns;expression;constructor(a,b,c){let d=`typed ${a.name}`;super({[d]:(...d)=>{let e=a(...b.assert(d));return c.assert(e)}}[d]),this.raw=a,this.params=b,this.returns=c;let e=b.expression;"["===e[0]&&"]"===e[e.length-1]?e=e.slice(1,-1):e.endsWith("[]")&&(e=`...${e}`),this.expression=`(${e}) => ${c?.expression??"unknown"}`}}let fo=`":" must be followed by exactly one return type e.g:
fn("string", ":", "number")(s => s.length)`;class fp extends T{$;constructor(a){super((...b)=>new fq(a)(...b),{bind:a}),this.$=a}in(a){return new fq(this.$,void 0===a?void 0:this.$.parse(a))}at(a,b){return new fq(this.$).at(a,b)}case(a,b){return new fq(this.$).case(a,b)}}class fq extends T{$;in;key;branches=[];constructor(a,b){super(a=>this.caseEntries(Object.entries(a).map(([a,b])=>"default"===a?[a,b]:[this.$.parse(a),b]))),this.$=a,this.in=b}at(a,b){return this.key&&u(ft),this.branches.length&&u(fs),this.key=a,b?this.match(b):this}case(a,b){return this.caseEntry(this.$.parse(a),b)}caseEntry(a,b){let c=(this.key?this.$.parse({[this.key]:a}):a).pipe(b);return this.branches.push(c),this}match(a){return this(a)}strings(a){return this.caseEntries(Object.entries(a).map(([a,b])=>"default"===a?[a,b]:[this.$.node("unit",{unit:a}),b]))}caseEntries(a){for(let b=0;b<a.length;b++){let[c,d]=a[b];if("default"===c)return b!==a.length-1&&u("default may only be specified as the last key of a switch definition"),this.default(d);if("function"!=typeof d)return u(`Value for case "${c}" must be a function (was ${n(d)})`);this.caseEntry(c,d)}return this}default(a){"function"==typeof a&&this.case(eI.unknown,a);let b={branches:this.branches,ordered:!0};("never"===a||"assert"===a)&&(b.meta={onFail:fr});let c=this.$.node("union",b);if(!this.in)return this.$.finalize(c);let d=this.in.pipe(c);return("never"===a||"assert"===a)&&(d=d.configureReferences({onFail:fr},"self")),this.$.finalize(d)}}let fr=a=>a.throw(),fs="A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')",ft="At most one key matcher may be specified per expression",fu=(a,b)=>{if(L(a)){if("="===a[1])return[b.$.parseOwnDefinitionFormat(a[0],b),"=",a[2]];if("?"===a[1])return[b.$.parseOwnDefinitionFormat(a[0],b),"?"]}return fP(a,b)},fv=(a,b,c,d)=>{a[b]=i(a[b],d.$.node(b,c))},fw=a=>`Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${aw(a)})`,fx=a=>"symbol"==typeof a?{kind:"required",normalized:a}:"?"===a[a.length-1]?"\\"===a[a.length-2]?{kind:"required",normalized:`${a.slice(0,-2)}?`}:{kind:"optional",normalized:a.slice(0,-1)}:"["===a[0]&&"]"===a[a.length-1]?{kind:"index",normalized:a.slice(1,-1)}:"\\"===a[0]&&"["===a[1]&&"]"===a[a.length-1]?{kind:"required",normalized:a.slice(1)}:"..."===a?{kind:"spread"}:"+"===a?{kind:"undeclared"}:{kind:"required",normalized:"\\..."===a?"...":"\\+"===a?"+":a},fy=a=>`Spread operand must resolve to an object literal type (was ${a})`,fz=(a,b)=>{if(void 0===a[2])return u(e0(a[1],""));let c=b.$.parseOwnDefinitionFormat(a[0],b),d=b.$.parseOwnDefinitionFormat(a[2],b);if("|"===a[1])return b.$.node("union",{branches:[c,d]});let e="&"===a[1]?bB(c,d,b.$):bC(c,d,b.$);return e instanceof bw?e.throw():e},fA=(a,b)=>`${":"===a?"Narrow":"Morph"} expression requires a function following '${a}' (was ${typeof b})`,fB={"[]":(a,b)=>b.$.parseOwnDefinitionFormat(a[0],b).array(),"?":()=>u(eT),"|":fz,"&":fz,":":(a,b)=>"function"!=typeof a[2]?u(fA(":",a[2])):b.$.parseOwnDefinitionFormat(a[0],b).constrain("predicate",a[2]),"=>":(a,b)=>"function"!=typeof a[2]?u(fA("=>",a[2])):b.$.parseOwnDefinitionFormat(a[0],b).pipe(a[2]),"|>":fz,"@":(a,b)=>b.$.parseOwnDefinitionFormat(a[0],b).configure(a[2],a[3]),"=":()=>u(eU)},fC={keyof:(a,b)=>b.$.parseOwnDefinitionFormat(a[1],b).keyof(),instanceof:(a,b)=>{if("function"!=typeof a[1])return u(fD(K(a[1])));let c=a.slice(1).map(a=>"function"==typeof a?b.$.node("proto",{proto:a}):u(fD(K(a))));return 1===c.length?c[0]:b.$.node("union",{branches:c})},"===":(a,b)=>b.$.units(a.slice(1))},fD=a=>`Expected a constructor following 'instanceof' operator (was ${a})`,fE=(a,b)=>a.defaultables||a.optionals?u(a.variadic?dZ:fL):(a.variadic?a.postfix=i(a.postfix,b):a.prefix=i(a.prefix,b),a),fF=(a,b)=>a.variadic?u(fM):(a.optionals=i(a.optionals,b),a),fG=(a,b,c)=>a.variadic?u(fM):a.optionals?u(fN):(a.defaultables=i(a.defaultables,[[b,c]]),a),fH=(a,b)=>(a.postfix&&u(fK),a.variadic?a.variadic.equals(b)||u(fK):a.variadic=b.internal,a),fI=(a,b)=>{let c=b.select({method:"find",kind:"sequence"});if(!c)return fH(a,ap.intrinsic.unknown);if(c.prefix)for(let b of c.prefix)fE(a,b);if(c.optionals)for(let b of c.optionals)fF(a,b);if(c.variadic&&fH(a,c.variadic),c.postfix)for(let b of c.postfix)fE(a,b);return a},fJ=a=>`Spread element must be an array (was ${a})`,fK="A tuple may have at most one variadic element",fL="A required element may not follow an optional element",fM="An optional element may not follow a variadic element",fN="A defaultable element may not follow an optional element without a default",fO={},fP=(a,b)=>{if("string"==typeof a){if(b.args&&Object.keys(b.args).some(b=>a.includes(b)))return fe(a,b);let c=fO[b.$.name]??={};return c[a]??=fe(a,b)}return m(a,"object")?fQ(a,b):u(fS(n(a)))},fQ=(a,b)=>{let c=J(a);switch(c){case void 0:if(aV(a,"root"))return a;return((a,b)=>{let c,d={};for(let[e,f]of D(a)){let a=fx(e);if("spread"===a.kind){if(!C(d))return u("Spread operator may only be used as the first key in an object");let a=b.$.parseOwnDefinitionFormat(f,b);if(a.equals(eI.object))continue;if(!a.hasKind("intersection")||!a.basis?.equals(eI.object))return u(fy(a.expression));c=a.structure;continue}if("undeclared"===a.kind){"reject"!==f&&"delete"!==f&&"ignore"!==f&&u(fw(f)),d.undeclared=f;continue}let g=fu(f,b);if("required"===a.kind){L(g)?fv(d,"optional","="===g[1]?{key:a.normalized,value:g[0],default:g[2]}:{key:a.normalized,value:g[0]},b):fv(d,"required",{key:a.normalized,value:g},b);continue}if(L(g)&&("?"===g[1]&&u("Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }"),"="===g[1]&&u("Only required keys may specify default values, e.g. { value: 'number = 0' }")),"optional"===a.kind){fv(d,"optional",{key:a.normalized,value:g},b);continue}let h=ed(b.$.parseOwnDefinitionFormat(a.normalized,b),g,b.$);h.index&&(d.index=i(d.index,h.index)),h.required&&(d.required=i(d.required,h.required))}let e=b.$.node("structure",d);return b.$.parseSchema({domain:"object",structure:c?.merge(e)??e})})(a,b);case"Array":return fR(a,b);case"RegExp":return b.$.node("intersection",{domain:"string",pattern:a},{prereduced:!0});case"Function":{let b=R(a)?a():a;if(aV(b,"root"))return b;return u(fS("Function"))}default:return u(fS(c??aw(a)))}},fR=(a,b)=>((a,b)=>void 0!==fC[a[0]]?fC[a[0]](a,b):void 0!==fB[a[1]]?fB[a[1]](a,b):null)(a,b)??((a,b)=>{let c=[{}],d=0;for(;d<a.length;){let e=!1;"..."===a[d]&&d<a.length-1&&(e=!0,d++);let f=fu(a[d],b),[g,h,i]=L(f)?f:[f];if(d++,e){if(!g.extends(ap.intrinsic.Array))return u(fJ(g.expression));c=c.flatMap(a=>g.distribute(b=>fI(aT(a),b)))}else c=c.map(a=>"?"===h?fF(a,g):"="===h?fG(a,g,i):fE(a,g))}return b.$.parseSchema(c.map(a=>C(a)?{proto:Array,exactLength:0}:{proto:Array,sequence:a}))})(a,b),fS=a=>`Type definitions must be strings or objects (was ${a})`;class fT extends T{constructor(a){super((...b)=>{if(1===b.length)return a.parse(b[0]);if(2===b.length&&"string"==typeof b[0]&&"<"===b[0][0]&&">"===b[0][b[0].length-1]){let c=b[0].slice(1,-1);return new bP(a.parseGenericParams(c,{}),b[1],a,a,null)}return a.parse(b)},{attach:Object.assign({errors:bi,hkt:V,$:a,raw:a.parse,module:a.constructor.module,scope:a.constructor.scope,declare:a.declare,define:a.define,match:a.match,generic:a.generic,schema:a.schema,keywords:a.ambient,unit:a.unit,enumerated:a.enumerated,instanceOf:a.instanceOf,valueOf:a.valueOf,or:a.or,and:a.and,merge:a.merge,pipe:a.pipe,fn:a.fn},a.ambientAttachments)})}}class fU extends eq{get ambientAttachments(){if(ap.typeAttachments)return this.cacheGetter("ambientAttachments",Q(ap.typeAttachments,(a,b)=>[a,this.bindReference(b)]))}preparseOwnAliasEntry(a,b){let c=a.indexOf("<");if(-1===c){if(aV(b,"module")||aV(b,"generic"))return[a,b];let c="ark"===this.name?a:"root"===a?this.name:`${this.name}.${a}`,d=this.resolvedConfig.keywords?.[c];return d&&(b=[b,"@",d]),[a,b]}">"!==a[a.length-1]&&u("'>' must be the last character of a generic declaration in a scope");let d=a.slice(0,c),e=a.slice(c+1,-1);return[d,()=>{let a;return a=this.parseGenericParams(e,{alias:d}),new bP(a,b,this,this,null)}]}parseGenericParams(a,b){return fj(new aH(a),[],this.createParseContext({...b,def:a,prefix:"generic"}))}normalizeRootScopeValue(a){return R(a)&&!aV(a,"generic")?a():a}preparseOwnDefinitionFormat(a,b){return{...b,def:a,prefix:b.alias??"type"}}parseOwnDefinitionFormat(a,b){b.alias&&b.alias in this.aliases||b.args||(b.args={this:b.id});let c=fP(a,b);if(L(c)){if("="===c[1])return u(eU);if("?"===c[1])return u(eT)}return c}unit=a=>this.units([a]);valueOf=a=>this.units((a=>Object.values(a).filter(b=>"number"==typeof b||"number"!=typeof a[b]))(a));enumerated=(...a)=>this.units(a);instanceOf=a=>this.node("proto",{proto:a},{prereduced:!0});or=(...a)=>this.schema(a.map(a=>this.parse(a)));and=(...a)=>a.reduce((a,b)=>a.and(this.parse(b)),this.intrinsic.unknown);merge=(...a)=>a.reduce((a,b)=>a.merge(this.parse(b)),this.intrinsic.object);pipe=(...a)=>this.intrinsic.unknown.pipe(...a);fn=new fm(this);match=new fp(this);declare=()=>({type:this.type});define(a){return a}type=new fT(this);static scope=(a,b={})=>new fU(a,b);static module=(a,b={})=>this.scope(a,b).export()}let fV=Object.assign(fU.scope,{define:a=>a});class fW extends V{description='merge an object\'s properties onto another like `Merge(User, { isAdmin: "true" })`'}let fX=eD(["base",eI.object],["props",eI.object])(a=>a.base.merge(a.props),fW),fY=fU.module({Key:eI.key,Merge:fX});class fZ extends V{}let f$=eD("element")(a=>{let b=a.element.exclude(eI.Array),c=b.array();return b.rawOr(c).pipe(e).distribute(a=>a.assertHasKind("morph").declareOut(c),eB)},fZ),f_=fU.module({root:eI.Array,readonly:"root",index:eI.nonNegativeIntegerString,liftFrom:f$},{name:"Array"}),f0=eB(["string",ap.FileConstructor]),f1=eB({meta:"an object representing parsed form data",domain:"object",index:{signature:"string",value:f0.rawOr(f0.array())}}),f2=fU.module({root:["instanceof",FormData],value:f0,parsed:f1,parse:eB({in:FormData,morphs:a=>{let b={};for(let[c,d]of a)if(c in b){let a=b[c];"string"==typeof a||a instanceof ap.FileConstructor?b[c]=[a,d]:a.push(d)}else b[c]=d;return b},declaredOut:f1})},{name:"FormData"}),f3=fU.module({Int8:["instanceof",Int8Array],Uint8:["instanceof",Uint8Array],Uint8Clamped:["instanceof",Uint8ClampedArray],Int16:["instanceof",Int16Array],Uint16:["instanceof",Uint16Array],Int32:["instanceof",Int32Array],Uint32:["instanceof",Uint32Array],Float32:["instanceof",Float32Array],Float64:["instanceof",Float64Array],BigInt64:["instanceof",BigInt64Array],BigUint64:["instanceof",BigUint64Array]},{name:"TypedArray"}),f4={Boolean:1,Number:1,String:1},f5=fU.module({...Q({...F,...H},(a,b)=>a in f4?[]:[a,["instanceof",b]]),Array:f_,TypedArray:f3,FormData:f2}),f6=eB({domain:{domain:"number",meta:"a number representing a Unix timestamp"},divisor:{rule:1,meta:"an integer representing a Unix timestamp"},min:{rule:-864e13,meta:"a Unix timestamp after -8640000000000000"},max:{rule:864e13,meta:"a Unix timestamp before 8640000000000000"},meta:"an integer representing a safe Unix timestamp"}),f7=eB({domain:"number",divisor:1}),f8=fU.module({root:eI.number,integer:f7,epoch:f6,safe:eB({domain:{domain:"number",numberAllowsNaN:!1},min:Number.MIN_SAFE_INTEGER,max:Number.MAX_SAFE_INTEGER}),NaN:["===",NaN],Infinity:["===",1/0],NegativeInfinity:["===",-1/0]},{name:"number"}),f9=(a,b,c)=>{let d={domain:"string",pattern:{rule:a.source,flags:a.flags,meta:b}};return c&&(d.meta={format:c}),eC("intersection",d)},ga=f9(ai,"a well-formed integer string"),gb=fU.module({root:ga,parse:eB({in:ga,morphs:(a,b)=>{let c=Number.parseInt(a);return Number.isSafeInteger(c)?c:b.error("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER")},declaredOut:eI.integer})},{name:"string.integer"}),gc=f9(/^[\dA-Fa-f]+$/,"hex characters only"),gd=fU.module({root:f9(/^(?:[\d+/A-Za-z]{4})*(?:[\d+/A-Za-z]{2}==|[\d+/A-Za-z]{3}=)?$/,"base64-encoded"),url:f9(/^(?:[\w-]{4})*(?:[\w-]{2}(?:==|%3D%3D)?|[\w-]{3}(?:=|%3D)?)?$/,"base64url-encoded")},{name:"string.base64"}),ge=f9(/^[A-Z].*$/,"capitalized"),gf=fU.module({root:eB({in:"string",morphs:a=>a.charAt(0).toUpperCase()+a.slice(1),declaredOut:ge}),preformatted:ge},{name:"string.capitalize"}),gg=eB({domain:"string",pattern:{meta:"a credit card number",rule:/^(?:4\d{12}(?:\d{3,6})?|5[1-5]\d{14}|(222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}|6(?:011|5\d\d)\d{12,15}|3[47]\d{13}|3(?:0[0-5]|[68]\d)\d{11}|(?:2131|1800|35\d{3})\d{11}|6[27]\d{14}|^(81\d{14,17}))$/.source},predicate:{meta:"a credit card number",predicate:a=>{let b,c=a.replace(/[ -]+/g,""),d=0,e=!1;for(let a=c.length-1;a>=0;a--)b=Number.parseInt(c.substring(a,a+1),10),e?(b*=2,d+=b>=10?b%10+1:b):d+=b,e=!e;return!!(d%10==0&&c)}}}),gh=eB({domain:"string",predicate:{meta:"a parsable date",predicate:a=>!Number.isNaN(new Date(a).valueOf())}}).assertHasKind("intersection"),gi=gb.root.internal.narrow((a,b)=>{let c=Number.parseInt(a),d=f8.epoch(c);return!(d instanceof bi)||(b.errors.merge(d),!1)}).configure({description:"an integer string representing a safe Unix timestamp"},"self").assertHasKind("intersection"),gj=fU.module({root:gi,parse:eB({in:gi,morphs:a=>new Date(a),declaredOut:eI.Date})},{name:"string.date.epoch"}),gk=f9(/^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))(T((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([,.]\d+(?!:))?)?(\17[0-5]\d([,.]\d+)?)?([Zz]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,"an ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) date").internal.assertHasKind("intersection"),gl=fU.module({root:gk,parse:eB({in:gk,morphs:a=>new Date(a),declaredOut:eI.Date})},{name:"string.date.iso"}),gm=fU.module({root:gh,parse:eB({declaredIn:gh,in:"string",morphs:(a,b)=>{let c=new Date(a);return Number.isNaN(c.valueOf())?b.error("a parsable date"):c},declaredOut:eI.Date}),iso:gl,epoch:gj},{name:"string.date"}),gn=f9(/^[\w%+.-]+@[\d.A-Za-z-]+\.[A-Za-z]{2,}$/,"an email address","email"),go="(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])",gp=`(${go}[.]){3}${go}`,gq=RegExp(`^${gp}$`),gr="(?:[0-9a-fA-F]{1,4})",gs=RegExp(`^((?:${gr}:){7}(?:${gr}|:)|(?:${gr}:){6}(?:${gp}|:${gr}|:)|(?:${gr}:){5}(?::${gp}|(:${gr}){1,2}|:)|(?:${gr}:){4}(?:(:${gr}){0,1}:${gp}|(:${gr}){1,3}|:)|(?:${gr}:){3}(?:(:${gr}){0,2}:${gp}|(:${gr}){1,4}|:)|(?:${gr}:){2}(?:(:${gr}){0,3}:${gp}|(:${gr}){1,5}|:)|(?:${gr}:){1}(?:(:${gr}){0,4}:${gp}|(:${gr}){1,6}|:)|(?::((?::${gr}){0,5}:${gp}|(?::${gr}){1,7}|:)))(%[0-9a-zA-Z.]{1,})?$`),gt=fU.module({root:["v4 | v6","@","an IP address"],v4:f9(gq,"an IPv4 address","ipv4"),v6:f9(gs,"an IPv6 address","ipv6")},{name:"string.ip"}),gu="a JSON string",gv=a=>{if(!(a instanceof SyntaxError))throw a;return`must be ${gu} (${a})`},gw=eB({meta:gu,domain:"string",predicate:{meta:gu,predicate:(a,b)=>{try{return JSON.parse(a),!0}catch(a){return b.reject({code:"predicate",expected:gu,problem:gv(a)})}}}}),gx=fU.module({root:gw,parse:eB({meta:"safe JSON string parser",in:"string",morphs:(a,b)=>{if(0===a.length)return b.error({code:"predicate",expected:gu,actual:"empty"});try{return JSON.parse(a)}catch(a){return b.error({code:"predicate",expected:gu,problem:gv(a)})}},declaredOut:eI.jsonObject})},{name:"string.json"}),gy=f9(/^[a-z]*$/,"only lowercase letters"),gz=fU.module({root:eB({in:"string",morphs:a=>a.toLowerCase(),declaredOut:gy}),preformatted:gy},{name:"string.lower"}),gA=["NFC","NFD","NFKC","NFKD"],gB=Q(gA,(a,b)=>[b,eB({domain:"string",predicate:a=>a.normalize(b)===a,meta:`${b}-normalized unicode`})]),gC=Q(gA,(a,b)=>[b,eB({in:"string",morphs:a=>a.normalize(b),declaredOut:gB[b]})]),gD=fU.module({root:gC.NFC,preformatted:gB.NFC},{name:"string.normalize.NFC"}),gE=fU.module({root:gC.NFD,preformatted:gB.NFD},{name:"string.normalize.NFD"}),gF=fU.module({root:gC.NFKC,preformatted:gB.NFKC},{name:"string.normalize.NFKC"}),gG=fU.module({root:gC.NFKD,preformatted:gB.NFKD},{name:"string.normalize.NFKD"}),gH=fU.module({root:"NFC",NFC:gD,NFD:gE,NFKC:gF,NFKD:gG},{name:"string.normalize"}),gI=f9(ag,"a well-formed numeric string"),gJ=fU.module({root:gI,parse:eB({in:gI,morphs:a=>Number.parseFloat(a),declaredOut:eI.number})},{name:"string.numeric"}),gK="a regex pattern",gL=eB({domain:"string",predicate:{meta:gK,predicate:(a,b)=>{try{return new RegExp(a),!0}catch(a){return b.reject({code:"predicate",expected:gK,problem:String(a)})}}},meta:{format:"regex"}}),gM=f9(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*)(?:\.(?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*))*))?(?:\+([\dA-Za-z-]+(?:\.[\dA-Za-z-]+)*))?$/,"a semantic version (see https://semver.org/)"),gN=f9(/^\S.*\S$|^\S?$/,"trimmed"),gO=fU.module({root:eB({in:"string",morphs:a=>a.trim(),declaredOut:gN}),preformatted:gN},{name:"string.trim"}),gP=f9(/^[A-Z]*$/,"only uppercase letters"),gQ=fU.module({root:eB({in:"string",morphs:a=>a.toUpperCase(),declaredOut:gP}),preformatted:gP},{name:"string.upper"}),gR=eB({domain:"string",predicate:{meta:"a URL string",predicate:a=>URL.canParse(a)},meta:{format:"uri"}}),gS=fU.module({root:gR,parse:eB({declaredIn:gR,in:"string",morphs:(a,b)=>{try{return new URL(a)}catch{return b.error("a URL string")}},declaredOut:eB(URL)})},{name:"string.url"}),gT=fU.module({root:["versioned | nil | max","@",{description:"a UUID",format:"uuid"}],"#nil":"'00000000-0000-0000-0000-000000000000'","#max":"'ffffffff-ffff-ffff-ffff-ffffffffffff'","#versioned":/[\da-f]{8}-[\da-f]{4}-[1-8][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}/i,v1:f9(/^[\da-f]{8}-[\da-f]{4}-1[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv1"),v2:f9(/^[\da-f]{8}-[\da-f]{4}-2[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv2"),v3:f9(/^[\da-f]{8}-[\da-f]{4}-3[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv3"),v4:f9(/^[\da-f]{8}-[\da-f]{4}-4[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv4"),v5:f9(/^[\da-f]{8}-[\da-f]{4}-5[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv5"),v6:f9(/^[\da-f]{8}-[\da-f]{4}-6[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv6"),v7:f9(/^[\da-f]{8}-[\da-f]{4}-7[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv7"),v8:f9(/^[\da-f]{8}-[\da-f]{4}-8[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv8")},{name:"string.uuid"}),gU=fU.module({root:eI.string,alpha:f9(/^[A-Za-z]*$/,"only letters"),alphanumeric:f9(/^[\dA-Za-z]*$/,"only letters and digits 0-9"),hex:gc,base64:gd,capitalize:gf,creditCard:gg,date:gm,digits:f9(/^\d*$/,"only digits 0-9"),email:gn,integer:gb,ip:gt,json:gx,lower:gz,normalize:gH,numeric:gJ,regex:gL,semver:gM,trim:gO,upper:gQ,url:gS,uuid:gT},{name:"string"}),gV=fU.module({bigint:eI.bigint,boolean:eI.boolean,false:eI.false,never:eI.never,null:eI.null,number:eI.number,object:eI.object,string:eI.string,symbol:eI.symbol,true:eI.true,unknown:eI.unknown,undefined:eI.undefined}),gW=fU.module({root:eI.unknown,any:eI.unknown},{name:"unknown"}),gX=fU.module({root:eI.jsonObject,stringify:eC("morph",{in:eI.jsonObject,morphs:a=>JSON.stringify(a),declaredOut:eI.string})},{name:"object.json"}),gY=fU.module({root:eI.object,json:gX},{name:"object"});class gZ extends V{description='instantiate an object from an index signature and corresponding value type like `Record("string", "number")`'}let g$=eD(["K",eI.key],"V")(a=>({domain:"object",index:{signature:a.K,value:a.V}}),gZ);class g_ extends V{description='pick a set of properties from an object like `Pick(User, "name | age")`'}let g0=eD(["T",eI.object],["K",eI.key])(a=>a.T.pick(a.K),g_);class g1 extends V{description='omit a set of properties from an object like `Omit(User, "age")`'}let g2=eD(["T",eI.object],["K",eI.key])(a=>a.T.omit(a.K),g1);class g3 extends V{description="make all named properties of an object optional like `Partial(User)`"}let g4=eD(["T",eI.object])(a=>a.T.partial(),g3);class g5 extends V{description="make all named properties of an object required like `Required(User)`"}let g6=eD(["T",eI.object])(a=>a.T.required(),g5);class g7 extends V{description='exclude branches of a union like `Exclude("boolean", "true")`'}let g8=eD("T","U")(a=>a.T.exclude(a.U),g7);class g9 extends V{description='extract branches of a union like `Extract("0 | false | 1", "number")`'}let ha=eD("T","U")(a=>a.T.extract(a.U),g9),hb=fU.module({Exclude:g8,Extract:ha,Omit:g2,Partial:g4,Pick:g0,Record:g$,Required:g6}),hc=fV({...gV,...hb,...f5,...fY,string:gU,number:f8,object:gY,unknown:gW},{prereducedAliases:!0,name:"ark"}),hd=hc.export();Object.assign(ap.ambient,hd),ap.typeAttachments={string:hd.string.root,number:hd.number.root,bigint:hd.bigint,boolean:hd.boolean,symbol:hd.symbol,undefined:hd.undefined,null:hd.null,object:hd.object.root,unknown:hd.unknown.root,false:hd.false,true:hd.true,never:hd.never,arrayIndex:hd.Array.index,Key:hd.Key,Record:hd.Record,Array:hd.Array.root,Date:hd.Date};let he=Object.assign(hc.type,ap.typeAttachments);hc.match,hc.fn,hc.generic,hc.schema,hc.define,hc.declare}};